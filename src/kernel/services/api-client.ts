//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_SignIn(body?: CreateUserCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/signin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_SignIn(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_SignIn(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_SignIn(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_Login(body?: AuthLoginQuery | null | undefined): Observable<TokenResponse> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_Login(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_Login(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TokenResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TokenResponse>;
    }));
  }

  protected processAuth_V1_Login(response: HttpResponseBase): Observable<TokenResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TokenResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<TokenResponse>(null as any);
  }

  /**
   * @return Success
   */
  auth_V1_Logout(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/logout";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_Logout(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_Logout(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_Logout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_ChangePassword(body?: ChangePasswordCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/changepassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_ChangePassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_ChangePassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_ChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_ForgotPassword(body?: ForgotPasswordQuery | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/password/forgot";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_ForgotPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_ForgotPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_ForgotPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  auth_V1_ResetPasswordCheckAccess(url: string): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/restore/{url}";
    if (url === undefined || url === null)
      throw new Error("The parameter 'url' must be defined.");
    url_ = url_.replace("{url}", encodeURIComponent("" + url));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_ResetPasswordCheckAccess(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_ResetPasswordCheckAccess(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_ResetPasswordCheckAccess(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  auth_V1_RestorePassword(body?: RestorePasswordCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/restore";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_RestorePassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_RestorePassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_RestorePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  auth_V1_CheckTemporaryPassword(): Observable<boolean> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/temporary";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_CheckTemporaryPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_CheckTemporaryPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<boolean>;
        }
      } else
        return _observableThrow(response_) as any as Observable<boolean>;
    }));
  }

  protected processAuth_V1_CheckTemporaryPassword(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(null as any);
  }

  /**
   * @return Success
   */
  balances_V1_GetUserBalance(): Observable<number> {
    let url_ = this.baseUrl + "/api-ciyw/balances/v1";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processBalances_V1_GetUserBalance(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processBalances_V1_GetUserBalance(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<number>;
        }
      } else
        return _observableThrow(response_) as any as Observable<number>;
    }));
  }

  protected processBalances_V1_GetUserBalance(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<number>(null as any);
  }

  /**
   * @return Success
   */
  categories_V1_CreateCategory(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/categories/v1";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCategories_V1_CreateCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCategories_V1_CreateCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processCategories_V1_CreateCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  dictionaries_V1_GetAll(): Observable<DictionariesResponse> {
    let url_ = this.baseUrl + "/api-ciyw/dictionaries/v1";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDictionaries_V1_GetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDictionaries_V1_GetAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DictionariesResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DictionariesResponse>;
    }));
  }

  protected processDictionaries_V1_GetAll(response: HttpResponseBase): Observable<DictionariesResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DictionariesResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DictionariesResponse>(null as any);
  }

  /**
   * @return Success
   */
  dictionaries_V1_GetByType(type: any): Observable<GuidDictionaryResponse> {
    let url_ = this.baseUrl + "/api-ciyw/dictionaries/v1/{type}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDictionaries_V1_GetByType(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDictionaries_V1_GetByType(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GuidDictionaryResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GuidDictionaryResponse>;
    }));
  }

  protected processDictionaries_V1_GetByType(response: HttpResponseBase): Observable<GuidDictionaryResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GuidDictionaryResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GuidDictionaryResponse>(null as any);
  }

  /**
   * @return Success
   */
  dictionaries_V1_GetByEnumType(type: any): Observable<StringDictionaryResponse> {
    let url_ = this.baseUrl + "/api-ciyw/dictionaries/v1/enum/{type}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDictionaries_V1_GetByEnumType(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDictionaries_V1_GetByEnumType(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StringDictionaryResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StringDictionaryResponse>;
    }));
  }

  protected processDictionaries_V1_GetByEnumType(response: HttpResponseBase): Observable<StringDictionaryResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = StringDictionaryResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<StringDictionaryResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  invoices_V1_GetUserInvoicesPOST(body?: UserInvoicesQuery | null | undefined): Observable<BalanceInvoicePageableResponse> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/history";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_GetUserInvoicesPOST(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_GetUserInvoicesPOST(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<BalanceInvoicePageableResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<BalanceInvoicePageableResponse>;
    }));
  }

  protected processInvoices_V1_GetUserInvoicesPOST(response: HttpResponseBase): Observable<BalanceInvoicePageableResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = BalanceInvoicePageableResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<BalanceInvoicePageableResponse>(null as any);
  }

  /**
   * @return Success
   */
  invoices_V1_GetUserInvoicesGET(): Observable<BalanceInvoicePageableResponse> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/monthly";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_GetUserInvoicesGET(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_GetUserInvoicesGET(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<BalanceInvoicePageableResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<BalanceInvoicePageableResponse>;
    }));
  }

  protected processInvoices_V1_GetUserInvoicesGET(response: HttpResponseBase): Observable<BalanceInvoicePageableResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = BalanceInvoicePageableResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<BalanceInvoicePageableResponse>(null as any);
  }

  /**
   * @return Success
   */
  invoices_V1_GetInvoiceById(id: string): Observable<BalanceInvoiceResponse> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_GetInvoiceById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_GetInvoiceById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<BalanceInvoiceResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<BalanceInvoiceResponse>;
    }));
  }

  protected processInvoices_V1_GetInvoiceById(response: HttpResponseBase): Observable<BalanceInvoiceResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = BalanceInvoiceResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<BalanceInvoiceResponse>(null as any);
  }

  /**
   * @return Success
   */
  invoices_V1_DeleteInvoice(id: string): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_DeleteInvoice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_DeleteInvoice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processInvoices_V1_DeleteInvoice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  invoices_V1_CreateInvoice(body?: CreateInvoiceCommand | null | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_CreateInvoice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_CreateInvoice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  protected processInvoices_V1_CreateInvoice(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<string>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  invoices_V1_UpdateInvoice(body?: UpdateInvoiceCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_UpdateInvoice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_UpdateInvoice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processInvoices_V1_UpdateInvoice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  notes_V1_CreateNote(body?: CreateOrUpdateNoteCommand | null | undefined): Observable<string> {
    let url_ = this.baseUrl + "/api-ciyw/notes/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotes_V1_CreateNote(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotes_V1_CreateNote(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  protected processNotes_V1_CreateNote(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<string>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  notes_V1_UpdateNote(body?: CreateOrUpdateNoteCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/notes/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotes_V1_UpdateNote(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotes_V1_UpdateNote(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processNotes_V1_UpdateNote(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  notes_V1_DeleteNote(id: string): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/notes/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotes_V1_DeleteNote(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotes_V1_DeleteNote(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processNotes_V1_DeleteNote(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  users_V1_CurrentUser(): Observable<CurrentUserResponse> {
    let url_ = this.baseUrl + "/api-ciyw/users/v1/current";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUsers_V1_CurrentUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUsers_V1_CurrentUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CurrentUserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CurrentUserResponse>;
    }));
  }

  protected processUsers_V1_CurrentUser(response: HttpResponseBase): Observable<CurrentUserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = CurrentUserResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<CurrentUserResponse>(null as any);
  }
}

export class AuthLoginQuery implements IAuthLoginQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  rememberMe?: boolean | undefined;

  constructor(data?: IAuthLoginQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.password = _data["password"];
      this.rememberMe = _data["rememberMe"];
    }
  }

  static fromJS(data: any): AuthLoginQuery {
    data = typeof data === 'object' ? data : {};
    let result = new AuthLoginQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["password"] = this.password;
    data["rememberMe"] = this.rememberMe;
    return data;
  }
}

export interface IAuthLoginQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  rememberMe?: boolean | undefined;
}

export class BalanceInvoicePageableResponse implements IBalanceInvoicePageableResponse {
  invoices?: BalanceInvoiceResponse[] | undefined;
  balance?: number | undefined;
  currency?: CurrencyResponse | undefined;
  totalCount?: number | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  isFull?: boolean | undefined;

  constructor(data?: IBalanceInvoicePageableResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["invoices"])) {
        this.invoices = [] as any;
        for (let item of _data["invoices"])
          this.invoices!.push(BalanceInvoiceResponse.fromJS(item));
      }
      this.balance = _data["balance"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.totalCount = _data["totalCount"];
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.isFull = _data["isFull"];
    }
  }

  static fromJS(data: any): BalanceInvoicePageableResponse {
    data = typeof data === 'object' ? data : {};
    let result = new BalanceInvoicePageableResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.invoices)) {
      data["invoices"] = [];
      for (let item of this.invoices)
        data["invoices"].push(item.toJSON());
    }
    data["balance"] = this.balance;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["totalCount"] = this.totalCount;
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["isFull"] = this.isFull;
    return data;
  }
}

export interface IBalanceInvoicePageableResponse {
  invoices?: BalanceInvoiceResponse[] | undefined;
  balance?: number | undefined;
  currency?: CurrencyResponse | undefined;
  totalCount?: number | undefined;
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  isFull?: boolean | undefined;
}

export class BalanceInvoiceResponse implements IBalanceInvoiceResponse {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  category?: CategoryResponse | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  date?: Date | undefined;
  note?: NoteResponse | undefined;
  type?: InvoiceTypeEnum | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IBalanceInvoiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.categoryId = _data["categoryId"];
      this.category = _data["category"] ? CategoryResponse.fromJS(_data["category"]) : <any>undefined;
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.note = _data["note"] ? NoteResponse.fromJS(_data["note"]) : <any>undefined;
      this.type = _data["type"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): BalanceInvoiceResponse {
    data = typeof data === 'object' ? data : {};
    let result = new BalanceInvoiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["note"] = this.note ? this.note.toJSON() : <any>undefined;
    data["type"] = this.type;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IBalanceInvoiceResponse {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  category?: CategoryResponse | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  date?: Date | undefined;
  note?: NoteResponse | undefined;
  type?: InvoiceTypeEnum | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class BaseDateRangeQuery implements IBaseDateRangeQuery {
  dateFrom?: Date | undefined;
  dateTo?: Date | undefined;

  constructor(data?: IBaseDateRangeQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
      this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): BaseDateRangeQuery {
    data = typeof data === 'object' ? data : {};
    let result = new BaseDateRangeQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
    data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
    return data;
  }
}

export interface IBaseDateRangeQuery {
  dateFrom?: Date | undefined;
  dateTo?: Date | undefined;
}

export class BaseIdsListQuery implements IBaseIdsListQuery {
  ids?: string[] | undefined;

  constructor(data?: IBaseIdsListQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["ids"])) {
        this.ids = [] as any;
        for (let item of _data["ids"])
          this.ids!.push(item);
      }
    }
  }

  static fromJS(data: any): BaseIdsListQuery {
    data = typeof data === 'object' ? data : {};
    let result = new BaseIdsListQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.ids)) {
      data["ids"] = [];
      for (let item of this.ids)
        data["ids"].push(item);
    }
    return data;
  }
}

export interface IBaseIdsListQuery {
  ids?: string[] | undefined;
}

export class BaseSortableQuery implements IBaseSortableQuery {
  column?: string | undefined;
  direction?: string | undefined;

  constructor(data?: IBaseSortableQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.column = _data["column"];
      this.direction = _data["direction"];
    }
  }

  static fromJS(data: any): BaseSortableQuery {
    data = typeof data === 'object' ? data : {};
    let result = new BaseSortableQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["column"] = this.column;
    data["direction"] = this.direction;
    return data;
  }
}

export interface IBaseSortableQuery {
  column?: string | undefined;
  direction?: string | undefined;
}

export class CategoryResponse implements ICategoryResponse {
  name?: string | undefined;
  description?: string | undefined;
  ico?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICategoryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.ico = _data["ico"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CategoryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["ico"] = this.ico;
    data["id"] = this.id;
    return data;
  }
}

export interface ICategoryResponse {
  name?: string | undefined;
  description?: string | undefined;
  ico?: string | undefined;
  id?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmationPassword?: string | undefined;

  constructor(data?: IChangePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.oldPassword = _data["oldPassword"];
      this.newPassword = _data["newPassword"];
      this.confirmationPassword = _data["confirmationPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["oldPassword"] = this.oldPassword;
    data["newPassword"] = this.newPassword;
    data["confirmationPassword"] = this.confirmationPassword;
    return data;
  }
}

export interface IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmationPassword?: string | undefined;
}

export class CreateInvoiceCommand implements ICreateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  note?: CreateOrUpdateNoteCommand | undefined;

  constructor(data?: ICreateInvoiceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.categoryId = _data["categoryId"];
      this.currencyId = _data["currencyId"];
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.type = _data["type"];
      this.note = _data["note"] ? CreateOrUpdateNoteCommand.fromJS(_data["note"]) : <any>undefined;
    }
  }

  static fromJS(data: any): CreateInvoiceCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateInvoiceCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["categoryId"] = this.categoryId;
    data["currencyId"] = this.currencyId;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["type"] = this.type;
    data["note"] = this.note ? this.note.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  note?: CreateOrUpdateNoteCommand | undefined;
}

export class CreateOrUpdateNoteCommand implements ICreateOrUpdateNoteCommand {
  name?: string | undefined;
  body?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICreateOrUpdateNoteCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.body = _data["body"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CreateOrUpdateNoteCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrUpdateNoteCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["body"] = this.body;
    data["id"] = this.id;
    return data;
  }
}

export interface ICreateOrUpdateNoteCommand {
  name?: string | undefined;
  body?: string | undefined;
  id?: string | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;

  constructor(data?: ICreateUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.confirmEmail = _data["confirmEmail"];
      this.isAgree = _data["isAgree"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isAgreeDigest = _data["isAgreeDigest"];
    }
  }

  static fromJS(data: any): CreateUserCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["confirmEmail"] = this.confirmEmail;
    data["isAgree"] = this.isAgree;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isAgreeDigest"] = this.isAgreeDigest;
    return data;
  }
}

export interface ICreateUserCommand {
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;
}

export class CurrencyResponse implements ICurrencyResponse {
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICurrencyResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isoCode = _data["isoCode"];
      this.symbol = _data["symbol"];
      this.name = _data["name"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CurrencyResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CurrencyResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isoCode"] = this.isoCode;
    data["symbol"] = this.symbol;
    data["name"] = this.name;
    data["id"] = this.id;
    return data;
  }
}

export interface ICurrencyResponse {
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  id?: string | undefined;
}

export class CurrentUserResponse implements ICurrentUserResponse {
  login?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  email?: string | undefined;
  isTemporaryPassword?: boolean | undefined;
  need2FAuthentication?: boolean | undefined;
  isBlocked?: boolean | undefined;
  roleId?: string | undefined;
  role?: string | undefined;
  currency?: CurrencyResponse | undefined;
  tariff?: TariffResponse | undefined;
  balanceAmount?: number | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: ICurrentUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.email = _data["email"];
      this.isTemporaryPassword = _data["isTemporaryPassword"];
      this.need2FAuthentication = _data["need2FAuthentication"];
      this.isBlocked = _data["isBlocked"];
      this.roleId = _data["roleId"];
      this.role = _data["role"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.tariff = _data["tariff"] ? TariffResponse.fromJS(_data["tariff"]) : <any>undefined;
      this.balanceAmount = _data["balanceAmount"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CurrentUserResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CurrentUserResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["email"] = this.email;
    data["isTemporaryPassword"] = this.isTemporaryPassword;
    data["need2FAuthentication"] = this.need2FAuthentication;
    data["isBlocked"] = this.isBlocked;
    data["roleId"] = this.roleId;
    data["role"] = this.role;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["tariff"] = this.tariff ? this.tariff.toJSON() : <any>undefined;
    data["balanceAmount"] = this.balanceAmount;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ICurrentUserResponse {
  login?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  email?: string | undefined;
  isTemporaryPassword?: boolean | undefined;
  need2FAuthentication?: boolean | undefined;
  isBlocked?: boolean | undefined;
  roleId?: string | undefined;
  role?: string | undefined;
  currency?: CurrencyResponse | undefined;
  tariff?: TariffResponse | undefined;
  balanceAmount?: number | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class DictionariesResponse implements IDictionariesResponse {
  currencies?: GuidDictionaryResponse | undefined;
  categories?: GuidDictionaryResponse | undefined;
  roles?: GuidDictionaryResponse | undefined;
  tariffs?: GuidDictionaryResponse | undefined;
  invoiceTypes?: StringDictionaryResponse | undefined;

  constructor(data?: IDictionariesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencies = _data["currencies"] ? GuidDictionaryResponse.fromJS(_data["currencies"]) : <any>undefined;
      this.categories = _data["categories"] ? GuidDictionaryResponse.fromJS(_data["categories"]) : <any>undefined;
      this.roles = _data["roles"] ? GuidDictionaryResponse.fromJS(_data["roles"]) : <any>undefined;
      this.tariffs = _data["tariffs"] ? GuidDictionaryResponse.fromJS(_data["tariffs"]) : <any>undefined;
      this.invoiceTypes = _data["invoiceTypes"] ? StringDictionaryResponse.fromJS(_data["invoiceTypes"]) : <any>undefined;
    }
  }

  static fromJS(data: any): DictionariesResponse {
    data = typeof data === 'object' ? data : {};
    let result = new DictionariesResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currencies"] = this.currencies ? this.currencies.toJSON() : <any>undefined;
    data["categories"] = this.categories ? this.categories.toJSON() : <any>undefined;
    data["roles"] = this.roles ? this.roles.toJSON() : <any>undefined;
    data["tariffs"] = this.tariffs ? this.tariffs.toJSON() : <any>undefined;
    data["invoiceTypes"] = this.invoiceTypes ? this.invoiceTypes.toJSON() : <any>undefined;
    return data;
  }
}

export interface IDictionariesResponse {
  currencies?: GuidDictionaryResponse | undefined;
  categories?: GuidDictionaryResponse | undefined;
  roles?: GuidDictionaryResponse | undefined;
  tariffs?: GuidDictionaryResponse | undefined;
  invoiceTypes?: StringDictionaryResponse | undefined;
}

export enum EntityTypeEnum {
  TARIFF = "TARIFF",
  CATEGORY = "CATEGORY",
  CURRENCY = "CURRENCY",
  ROLE = "ROLE",
  INVOICE_TYPE = "INVOICE_TYPE",
}

export class ErrorMessage implements IErrorMessage {
  invalidFields?: InvalidFieldInfo[] | undefined;
  message?: string | undefined;
  statusCode?: number | undefined;

  constructor(data?: IErrorMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["invalidFields"])) {
        this.invalidFields = [] as any;
        for (let item of _data["invalidFields"])
          this.invalidFields!.push(InvalidFieldInfo.fromJS(item));
      }
      this.message = _data["message"];
      this.statusCode = _data["statusCode"];
    }
  }

  static fromJS(data: any): ErrorMessage {
    data = typeof data === 'object' ? data : {};
    let result = new ErrorMessage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.invalidFields)) {
      data["invalidFields"] = [];
      for (let item of this.invalidFields)
        data["invalidFields"].push(item.toJSON());
    }
    data["message"] = this.message;
    data["statusCode"] = this.statusCode;
    return data;
  }
}

export interface IErrorMessage {
  invalidFields?: InvalidFieldInfo[] | undefined;
  message?: string | undefined;
  statusCode?: number | undefined;
}

export class ForgotPasswordQuery implements IForgotPasswordQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IForgotPasswordQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
    }
  }

  static fromJS(data: any): ForgotPasswordQuery {
    data = typeof data === 'object' ? data : {};
    let result = new ForgotPasswordQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    return data;
  }
}

export interface IForgotPasswordQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
}

export class GuidDictionaryItemResponse implements IGuidDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;

  constructor(data?: IGuidDictionaryItemResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.hint = _data["hint"];
    }
  }

  static fromJS(data: any): GuidDictionaryItemResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GuidDictionaryItemResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["hint"] = this.hint;
    return data;
  }
}

export interface IGuidDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;
}

export class GuidDictionaryResponse implements IGuidDictionaryResponse {
  items?: GuidDictionaryItemResponse[] | undefined;

  constructor(data?: IGuidDictionaryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(GuidDictionaryItemResponse.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GuidDictionaryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GuidDictionaryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGuidDictionaryResponse {
  items?: GuidDictionaryItemResponse[] | undefined;
}

export class InvalidFieldInfo implements IInvalidFieldInfo {
  propertyName?: string | undefined;
  errorMessage?: string | undefined;

  constructor(data?: IInvalidFieldInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName = _data["propertyName"];
      this.errorMessage = _data["errorMessage"];
    }
  }

  static fromJS(data: any): InvalidFieldInfo {
    data = typeof data === 'object' ? data : {};
    let result = new InvalidFieldInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["propertyName"] = this.propertyName;
    data["errorMessage"] = this.errorMessage;
    return data;
  }
}

export interface IInvalidFieldInfo {
  propertyName?: string | undefined;
  errorMessage?: string | undefined;
}

export enum InvoiceTypeEnum {
  INCOME = "INCOME",
  EXPENSE = "EXPENSE",
}

export class NoteResponse implements INoteResponse {
  name?: string | undefined;
  body?: string | undefined;
  invoiceId?: string | undefined;
  userId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: INoteResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.body = _data["body"];
      this.invoiceId = _data["invoiceId"];
      this.userId = _data["userId"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): NoteResponse {
    data = typeof data === 'object' ? data : {};
    let result = new NoteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["body"] = this.body;
    data["invoiceId"] = this.invoiceId;
    data["userId"] = this.userId;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface INoteResponse {
  name?: string | undefined;
  body?: string | undefined;
  invoiceId?: string | undefined;
  userId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class Paginator implements IPaginator {
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  isFull?: boolean | undefined;

  constructor(data?: IPaginator) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.isFull = _data["isFull"];
    }
  }

  static fromJS(data: any): Paginator {
    data = typeof data === 'object' ? data : {};
    let result = new Paginator();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["isFull"] = this.isFull;
    return data;
  }
}

export interface IPaginator {
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  isFull?: boolean | undefined;
}

export class RestorePasswordCommand implements IRestorePasswordCommand {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  url?: string | undefined;

  constructor(data?: IRestorePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.url = _data["url"];
    }
  }

  static fromJS(data: any): RestorePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RestorePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["url"] = this.url;
    return data;
  }
}

export interface IRestorePasswordCommand {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  url?: string | undefined;
}

export class StringDictionaryItemResponse implements IStringDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;

  constructor(data?: IStringDictionaryItemResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.hint = _data["hint"];
    }
  }

  static fromJS(data: any): StringDictionaryItemResponse {
    data = typeof data === 'object' ? data : {};
    let result = new StringDictionaryItemResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["hint"] = this.hint;
    return data;
  }
}

export interface IStringDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;
}

export class StringDictionaryResponse implements IStringDictionaryResponse {
  items?: StringDictionaryItemResponse[] | undefined;

  constructor(data?: IStringDictionaryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(StringDictionaryItemResponse.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StringDictionaryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new StringDictionaryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IStringDictionaryResponse {
  items?: StringDictionaryItemResponse[] | undefined;
}

export class TariffResponse implements ITariffResponse {
  name?: string | undefined;
  description?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: ITariffResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TariffResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TariffResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ITariffResponse {
  name?: string | undefined;
  description?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
  scheme?: string | undefined;
  provider?: string | undefined;
  value?: any | undefined;
  expired?: number | undefined;

  constructor(data?: ITokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.scheme = _data["scheme"];
      this.provider = _data["provider"];
      this.value = _data["value"];
      this.expired = _data["expired"];
    }
  }

  static fromJS(data: any): TokenResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["scheme"] = this.scheme;
    data["provider"] = this.provider;
    data["value"] = this.value;
    data["expired"] = this.expired;
    return data;
  }
}

export interface ITokenResponse {
  scheme?: string | undefined;
  provider?: string | undefined;
  value?: any | undefined;
  expired?: number | undefined;
}

export class UpdateInvoiceCommand implements IUpdateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  id?: string | undefined;

  constructor(data?: IUpdateInvoiceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.categoryId = _data["categoryId"];
      this.currencyId = _data["currencyId"];
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.type = _data["type"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateInvoiceCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateInvoiceCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["categoryId"] = this.categoryId;
    data["currencyId"] = this.currencyId;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["type"] = this.type;
    data["id"] = this.id;
    return data;
  }
}

export interface IUpdateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  id?: string | undefined;
}

export class UserInvoicesQuery implements IUserInvoicesQuery {
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;

  constructor(data?: IUserInvoicesQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ids = _data["ids"] ? BaseIdsListQuery.fromJS(_data["ids"]) : <any>undefined;
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.dateRange = _data["dateRange"] ? BaseDateRangeQuery.fromJS(_data["dateRange"]) : <any>undefined;
      this.sort = _data["sort"] ? BaseSortableQuery.fromJS(_data["sort"]) : <any>undefined;
    }
  }

  static fromJS(data: any): UserInvoicesQuery {
    data = typeof data === 'object' ? data : {};
    let result = new UserInvoicesQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ids"] = this.ids ? this.ids.toJSON() : <any>undefined;
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["dateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
    data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserInvoicesQuery {
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
}

export class ApiException extends Error {
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "";
  }

  /**
   * @return Success
   */
  adminCategories_V1_CreateCategory(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/admincategories/v1";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminCategories_V1_CreateCategory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminCategories_V1_CreateCategory(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAdminCategories_V1_CreateCategory(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  adminUsers_V1_CreateUserByAdmin(body?: CreateUserByAdminCommand | null | undefined): Observable<UserResponseUserMappedHelperResponse> {
    let url_ = this.baseUrl + "/api-ciyw/adminusers/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminUsers_V1_CreateUserByAdmin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminUsers_V1_CreateUserByAdmin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UserResponseUserMappedHelperResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UserResponseUserMappedHelperResponse>;
    }));
  }

  protected processAdminUsers_V1_CreateUserByAdmin(response: HttpResponseBase): Observable<UserResponseUserMappedHelperResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserResponseUserMappedHelperResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserResponseUserMappedHelperResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  adminUsers_V1_UpdateUserByAdmin(body?: UpdateUserByAdminCommand | null | undefined): Observable<UserResponseUserMappedHelperResponse> {
    let url_ = this.baseUrl + "/api-ciyw/adminusers/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminUsers_V1_UpdateUserByAdmin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminUsers_V1_UpdateUserByAdmin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UserResponseUserMappedHelperResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UserResponseUserMappedHelperResponse>;
    }));
  }

  protected processAdminUsers_V1_UpdateUserByAdmin(response: HttpResponseBase): Observable<UserResponseUserMappedHelperResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserResponseUserMappedHelperResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserResponseUserMappedHelperResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  adminUsers_V1_GetUsers(body?: UsersQuery | null | undefined): Observable<UserResponseListWithIncludeHelper> {
    let url_ = this.baseUrl + "/api-ciyw/adminusers/v1/filter";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminUsers_V1_GetUsers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminUsers_V1_GetUsers(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UserResponseListWithIncludeHelper>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UserResponseListWithIncludeHelper>;
    }));
  }

  protected processAdminUsers_V1_GetUsers(response: HttpResponseBase): Observable<UserResponseListWithIncludeHelper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserResponseListWithIncludeHelper.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserResponseListWithIncludeHelper>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  adminUsers_V1_GetUsersImages(body?: UsersImagesQuery | null | undefined): Observable<ImageDataResponseListWithIncludeHelper> {
    let url_ = this.baseUrl + "/api-ciyw/adminusers/v1/images/ids";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminUsers_V1_GetUsersImages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminUsers_V1_GetUsersImages(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ImageDataResponseListWithIncludeHelper>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ImageDataResponseListWithIncludeHelper>;
    }));
  }

  protected processAdminUsers_V1_GetUsersImages(response: HttpResponseBase): Observable<ImageDataResponseListWithIncludeHelper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ImageDataResponseListWithIncludeHelper.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ImageDataResponseListWithIncludeHelper>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  adminUsers_V1_GetUserImage(body?: UserImageQuery | null | undefined): Observable<ImageDataResponse> {
    let url_ = this.baseUrl + "/api-ciyw/adminusers/v1/images";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAdminUsers_V1_GetUserImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAdminUsers_V1_GetUserImage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ImageDataResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ImageDataResponse>;
    }));
  }

  protected processAdminUsers_V1_GetUserImage(response: HttpResponseBase): Observable<ImageDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ImageDataResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ImageDataResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_SignIn(body?: CreateUserCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/signin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_SignIn(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_SignIn(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_SignIn(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_Login(body?: AuthLoginQuery | null | undefined): Observable<TokenResponse> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_Login(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_Login(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TokenResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TokenResponse>;
    }));
  }

  protected processAuth_V1_Login(response: HttpResponseBase): Observable<TokenResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TokenResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<TokenResponse>(null as any);
  }

  /**
   * @return Success
   */
  auth_V1_Logout(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/logout";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_Logout(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_Logout(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_Logout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_ChangePassword(body?: ChangePasswordCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/changepassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_ChangePassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_ChangePassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_ChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  auth_V1_ForgotPassword(body?: ForgotPasswordQuery | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/password/forgot";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_ForgotPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_ForgotPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_ForgotPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  auth_V1_RestorePassword(url: string, body?: RestorePasswordCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/restore/{url}";
    if (url === undefined || url === null)
      throw new Error("The parameter 'url' must be defined.");
    url_ = url_.replace("{url}", encodeURIComponent("" + url));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_RestorePassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_RestorePassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAuth_V1_RestorePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  auth_V1_CheckTemporaryPassword(): Observable<boolean> {
    let url_ = this.baseUrl + "/api-ciyw/auth/v1/temporary";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAuth_V1_CheckTemporaryPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAuth_V1_CheckTemporaryPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<boolean>;
        }
      } else
        return _observableThrow(response_) as any as Observable<boolean>;
    }));
  }

  protected processAuth_V1_CheckTemporaryPassword(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<boolean>(null as any);
  }

  /**
   * @return Success
   */
  balances_V1_GetUserBalance(): Observable<number> {
    let url_ = this.baseUrl + "/api-ciyw/balances/v1";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processBalances_V1_GetUserBalance(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processBalances_V1_GetUserBalance(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<number>;
        }
      } else
        return _observableThrow(response_) as any as Observable<number>;
    }));
  }

  protected processBalances_V1_GetUserBalance(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;

        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<number>(null as any);
  }

  /**
   * @return Success
   */
  definitions_V1_GetAuthSchema(type: any): Observable<FormModel> {
    let url_ = this.baseUrl + "/api-ciyw/definitions/v1/schemas/auth/{type}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDefinitions_V1_GetAuthSchema(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDefinitions_V1_GetAuthSchema(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FormModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FormModel>;
    }));
  }

  protected processDefinitions_V1_GetAuthSchema(response: HttpResponseBase): Observable<FormModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FormModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FormModel>(null as any);
  }

  /**
   * @return Success
   */
  definitions_V1_GetNonAuthSchema(type: any): Observable<FormModel> {
    let url_ = this.baseUrl + "/api-ciyw/definitions/v1/schemas/{type}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDefinitions_V1_GetNonAuthSchema(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDefinitions_V1_GetNonAuthSchema(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FormModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FormModel>;
    }));
  }

  protected processDefinitions_V1_GetNonAuthSchema(response: HttpResponseBase): Observable<FormModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = FormModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FormModel>(null as any);
  }

  /**
   * @return Success
   */
  dictionaries_V1_GetAll(): Observable<DictionariesResponse> {
    let url_ = this.baseUrl + "/api-ciyw/dictionaries/v1";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDictionaries_V1_GetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDictionaries_V1_GetAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DictionariesResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DictionariesResponse>;
    }));
  }

  protected processDictionaries_V1_GetAll(response: HttpResponseBase): Observable<DictionariesResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = DictionariesResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<DictionariesResponse>(null as any);
  }

  /**
   * @return Success
   */
  dictionaries_V1_GetByType(type: any, typ: string): Observable<GuidDictionaryResponse> {
    let url_ = this.baseUrl + "/api-ciyw/dictionaries/v1/{typ}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    if (typ === undefined || typ === null)
      throw new Error("The parameter 'typ' must be defined.");
    url_ = url_.replace("{typ}", encodeURIComponent("" + typ));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDictionaries_V1_GetByType(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDictionaries_V1_GetByType(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<GuidDictionaryResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<GuidDictionaryResponse>;
    }));
  }

  protected processDictionaries_V1_GetByType(response: HttpResponseBase): Observable<GuidDictionaryResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GuidDictionaryResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<GuidDictionaryResponse>(null as any);
  }

  /**
   * @return Success
   */
  dictionaries_V1_GetByEnumType(type: any, typ: string): Observable<StringDictionaryResponse> {
    let url_ = this.baseUrl + "/api-ciyw/dictionaries/v1/enum/{typ}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    if (typ === undefined || typ === null)
      throw new Error("The parameter 'typ' must be defined.");
    url_ = url_.replace("{typ}", encodeURIComponent("" + typ));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDictionaries_V1_GetByEnumType(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDictionaries_V1_GetByEnumType(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StringDictionaryResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StringDictionaryResponse>;
    }));
  }

  protected processDictionaries_V1_GetByEnumType(response: HttpResponseBase): Observable<StringDictionaryResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = StringDictionaryResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<StringDictionaryResponse>(null as any);
  }

  elasticSearch_V1_GetInvoiceBy222Id(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1/removeall";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_V1_GetInvoiceBy222Id(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_V1_GetInvoiceBy222Id(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_V1_GetInvoiceBy222Id(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  elasticSearch_V1_GetInvoiceBy22Id(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1/removeallindexes";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_V1_GetInvoiceBy22Id(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_V1_GetInvoiceBy22Id(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_V1_GetInvoiceBy22Id(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  elasticSearch_Get(keyword?: (string | undefined)[] | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1?";
    if (keyword !== undefined && keyword !== null)
      keyword && keyword.forEach(item => { url_ += "keyword=" + encodeURIComponent("" + item) + "&"; });
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_Get(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_Get(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_Get(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  elasticSearch_V1_GetInvoiceBy22IdA412sync(body?: UserSearchModel | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1/additem";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_V1_GetInvoiceBy22IdA412sync(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_V1_GetInvoiceBy22IdA412sync(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_V1_GetInvoiceBy22IdA412sync(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  elasticSearch_V1_GetUsersyId(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1/getallusers";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_V1_GetUsersyId(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_V1_GetUsersyId(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_V1_GetUsersyId(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  elasticSearch_V1_GetUsersy11Id(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1/testmessage";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_V1_GetUsersy11Id(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_V1_GetUsersy11Id(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_V1_GetUsersy11Id(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  elasticSearch_V1_GetUsersy111Id(): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/elasticsearch/v1/testmessage12";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processElasticSearch_V1_GetUsersy111Id(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processElasticSearch_V1_GetUsersy111Id(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processElasticSearch_V1_GetUsersy111Id(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param file (optional)
   * @return Success
   */
  images_V1_CreateImage(type: any, userId: string, file?: FileParameter | null | undefined): Observable<ImageDataResponse> {
    let url_ = this.baseUrl + "/api-ciyw/images/v1/{type}/{userId}";
    if (type === undefined || type === null)
      throw new Error("The parameter 'type' must be defined.");
    url_ = url_.replace("{type}", encodeURIComponent("" + type));
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processImages_V1_CreateImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processImages_V1_CreateImage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ImageDataResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ImageDataResponse>;
    }));
  }

  protected processImages_V1_CreateImage(response: HttpResponseBase): Observable<ImageDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ImageDataResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ImageDataResponse>(null as any);
  }

  /**
   * @param file (optional)
   * @return Success
   */
  images_V1_UpdateImage(id: string, file?: FileParameter | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/images/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processImages_V1_UpdateImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processImages_V1_UpdateImage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processImages_V1_UpdateImage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param file (optional)
   * @return Success
   */
  images_V1_DeleteImage(id: string, file?: FileParameter | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/images/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processImages_V1_DeleteImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processImages_V1_DeleteImage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processImages_V1_DeleteImage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  invoices_V1_GetUserInvoicesPOST(body?: UserInvoicesQuery | null | undefined): Observable<InvoiceResponseListWithIncludeHelper> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/history";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_GetUserInvoicesPOST(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_GetUserInvoicesPOST(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<InvoiceResponseListWithIncludeHelper>;
        }
      } else
        return _observableThrow(response_) as any as Observable<InvoiceResponseListWithIncludeHelper>;
    }));
  }

  protected processInvoices_V1_GetUserInvoicesPOST(response: HttpResponseBase): Observable<InvoiceResponseListWithIncludeHelper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InvoiceResponseListWithIncludeHelper.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<InvoiceResponseListWithIncludeHelper>(null as any);
  }

  /**
   * @return Success
   */
  invoices_V1_GetUserInvoicesGET(): Observable<InvoiceResponseListWithIncludeHelper> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/monthly";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_GetUserInvoicesGET(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_GetUserInvoicesGET(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<InvoiceResponseListWithIncludeHelper>;
        }
      } else
        return _observableThrow(response_) as any as Observable<InvoiceResponseListWithIncludeHelper>;
    }));
  }

  protected processInvoices_V1_GetUserInvoicesGET(response: HttpResponseBase): Observable<InvoiceResponseListWithIncludeHelper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InvoiceResponseListWithIncludeHelper.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<InvoiceResponseListWithIncludeHelper>(null as any);
  }

  /**
   * @return Success
   */
  invoices_V1_GetInvoiceById(id: string): Observable<InvoiceResponse> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_GetInvoiceById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_GetInvoiceById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<InvoiceResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<InvoiceResponse>;
    }));
  }

  protected processInvoices_V1_GetInvoiceById(response: HttpResponseBase): Observable<InvoiceResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InvoiceResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<InvoiceResponse>(null as any);
  }

  /**
   * @return Success
   */
  invoices_V1_DeleteInvoice(id: string): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_DeleteInvoice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_DeleteInvoice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processInvoices_V1_DeleteInvoice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  invoices_V1_CreateInvoice(body?: CreateInvoiceCommand | null | undefined): Observable<InvoiceResponse> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_CreateInvoice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_CreateInvoice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<InvoiceResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<InvoiceResponse>;
    }));
  }

  protected processInvoices_V1_CreateInvoice(response: HttpResponseBase): Observable<InvoiceResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = InvoiceResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<InvoiceResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  invoices_V1_UpdateInvoice(body?: UpdateInvoiceCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/invoices/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInvoices_V1_UpdateInvoice(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInvoices_V1_UpdateInvoice(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processInvoices_V1_UpdateInvoice(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  notes_V1_CreateNote(body?: CreateOrUpdateNoteCommand | null | undefined): Observable<NoteResponse> {
    let url_ = this.baseUrl + "/api-ciyw/notes/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotes_V1_CreateNote(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotes_V1_CreateNote(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<NoteResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<NoteResponse>;
    }));
  }

  protected processNotes_V1_CreateNote(response: HttpResponseBase): Observable<NoteResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NoteResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NoteResponse>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  notes_V1_UpdateNote(body?: CreateOrUpdateNoteCommand | null | undefined): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/notes/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotes_V1_UpdateNote(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotes_V1_UpdateNote(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processNotes_V1_UpdateNote(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @return Success
   */
  notes_V1_DeleteNote(id: string): Observable<void> {
    let url_ = this.baseUrl + "/api-ciyw/notes/v1/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processNotes_V1_DeleteNote(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processNotes_V1_DeleteNote(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processNotes_V1_DeleteNote(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(null as any);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(null as any);
  }

  /**
   * @param body (optional)
   * @return Success
   */
  tariffs_V1_GetTariffs(body?: TariffsQuery | null | undefined): Observable<TariffResponseListWithIncludeHelper> {
    let url_ = this.baseUrl + "/api-ciyw/tariffs/v1";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processTariffs_V1_GetTariffs(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processTariffs_V1_GetTariffs(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TariffResponseListWithIncludeHelper>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TariffResponseListWithIncludeHelper>;
    }));
  }

  protected processTariffs_V1_GetTariffs(response: HttpResponseBase): Observable<TariffResponseListWithIncludeHelper> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TariffResponseListWithIncludeHelper.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<TariffResponseListWithIncludeHelper>(null as any);
  }

  /**
   * @return Success
   */
  users_V1_CurrentUser(): Observable<UserResponse> {
    let url_ = this.baseUrl + "/api-ciyw/users/v1/current";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUsers_V1_CurrentUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUsers_V1_CurrentUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UserResponse>;
    }));
  }

  protected processUsers_V1_CurrentUser(response: HttpResponseBase): Observable<UserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserResponse>(null as any);
  }

  /**
   * @return Success
   */
  users_V1_ActiveUser(): Observable<ActiveUserResponse> {
    let url_ = this.baseUrl + "/api-ciyw/users/v1/active";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUsers_V1_ActiveUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUsers_V1_ActiveUser(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ActiveUserResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ActiveUserResponse>;
    }));
  }

  protected processUsers_V1_ActiveUser(response: HttpResponseBase): Observable<ActiveUserResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ActiveUserResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ActiveUserResponse>(null as any);
  }

  /**
   * @return Success
   */
  users_V1_GetCurrentUserImage(): Observable<ImageDataResponse> {
    let url_ = this.baseUrl + "/api-ciyw/users/v1/avatar";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUsers_V1_GetCurrentUserImage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUsers_V1_GetCurrentUserImage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ImageDataResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ImageDataResponse>;
    }));
  }

  protected processUsers_V1_GetCurrentUserImage(response: HttpResponseBase): Observable<ImageDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ErrorMessage.fromJS(resultData400);
        return throwException("Bad Request", status, _responseText, _headers, result400);
      }));
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result401: any = null;
        let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result401 = ErrorMessage.fromJS(resultData401);
        return throwException("Unauthorized", status, _responseText, _headers, result401);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ErrorMessage.fromJS(resultData403);
        return throwException("Forbidden", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ErrorMessage.fromJS(resultData404);
        return throwException("Not Found", status, _responseText, _headers, result404);
      }));
    } else if (status === 409) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result409: any = null;
        let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result409 = ErrorMessage.fromJS(resultData409);
        return throwException("Conflict", status, _responseText, _headers, result409);
      }));
    } else if (status === 417) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result417: any = null;
        let resultData417 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result417 = ErrorMessage.fromJS(resultData417);
        return throwException("Client Error", status, _responseText, _headers, result417);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result500: any = null;
        let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result500 = ErrorMessage.fromJS(resultData500);
        return throwException("Server Error", status, _responseText, _headers, result500);
      }));
    } else if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ImageDataResponse.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ImageDataResponse>(null as any);
  }
}

export class ActiveUserResponse implements IActiveUserResponse {
  userId?: string | undefined;
  connectionId?: string | undefined;
  groups?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IActiveUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.connectionId = _data["connectionId"];
      this.groups = _data["groups"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ActiveUserResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ActiveUserResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["userId"] = this.userId;
    data["connectionId"] = this.connectionId;
    data["groups"] = this.groups;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IActiveUserResponse {
  userId?: string | undefined;
  connectionId?: string | undefined;
  groups?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class AuthLoginQuery implements IAuthLoginQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  rememberMe?: boolean | undefined;

  constructor(data?: IAuthLoginQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.password = _data["password"];
      this.rememberMe = _data["rememberMe"];
    }
  }

  static fromJS(data: any): AuthLoginQuery {
    data = typeof data === 'object' ? data : {};
    let result = new AuthLoginQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["password"] = this.password;
    data["rememberMe"] = this.rememberMe;
    return data;
  }
}

export interface IAuthLoginQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  rememberMe?: boolean | undefined;
}

export class BaseDateRangeQuery implements IBaseDateRangeQuery {
  dateFrom?: Date | undefined;
  dateTo?: Date | undefined;

  constructor(data?: IBaseDateRangeQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.dateFrom = _data["dateFrom"] ? new Date(_data["dateFrom"].toString()) : <any>undefined;
      this.dateTo = _data["dateTo"] ? new Date(_data["dateTo"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): BaseDateRangeQuery {
    data = typeof data === 'object' ? data : {};
    let result = new BaseDateRangeQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["dateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
    data["dateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
    return data;
  }
}

export interface IBaseDateRangeQuery {
  dateFrom?: Date | undefined;
  dateTo?: Date | undefined;
}

export class BaseIdsListQuery implements IBaseIdsListQuery {
  ids?: string[] | undefined;

  constructor(data?: IBaseIdsListQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["ids"])) {
        this.ids = [] as any;
        for (let item of _data["ids"])
          this.ids!.push(item);
      }
    }
  }

  static fromJS(data: any): BaseIdsListQuery {
    data = typeof data === 'object' ? data : {};
    let result = new BaseIdsListQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.ids)) {
      data["ids"] = [];
      for (let item of this.ids)
        data["ids"].push(item);
    }
    return data;
  }
}

export interface IBaseIdsListQuery {
  ids?: string[] | undefined;
}

export class BaseSortableQuery implements IBaseSortableQuery {
  parentClass?: string | undefined;
  column?: string | undefined;
  direction?: string | undefined;

  constructor(data?: IBaseSortableQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.parentClass = _data["parentClass"];
      this.column = _data["column"];
      this.direction = _data["direction"];
    }
  }

  static fromJS(data: any): BaseSortableQuery {
    data = typeof data === 'object' ? data : {};
    let result = new BaseSortableQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["parentClass"] = this.parentClass;
    data["column"] = this.column;
    data["direction"] = this.direction;
    return data;
  }
}

export interface IBaseSortableQuery {
  parentClass?: string | undefined;
  column?: string | undefined;
  direction?: string | undefined;
}

export class Category implements ICategory {
  name?: string | undefined;
  description?: string | undefined;
  ico?: string | undefined;
  isActive?: boolean | undefined;
  userCategories?: UserCategory[] | undefined;
  invoices?: Invoice[] | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: ICategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.ico = _data["ico"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["userCategories"])) {
        this.userCategories = [] as any;
        for (let item of _data["userCategories"])
          this.userCategories!.push(UserCategory.fromJS(item));
      }
      if (Array.isArray(_data["invoices"])) {
        this.invoices = [] as any;
        for (let item of _data["invoices"])
          this.invoices!.push(Invoice.fromJS(item));
      }
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Category {
    data = typeof data === 'object' ? data : {};
    let result = new Category();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["ico"] = this.ico;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.userCategories)) {
      data["userCategories"] = [];
      for (let item of this.userCategories)
        data["userCategories"].push(item.toJSON());
    }
    if (Array.isArray(this.invoices)) {
      data["invoices"] = [];
      for (let item of this.invoices)
        data["invoices"].push(item.toJSON());
    }
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ICategory {
  name?: string | undefined;
  description?: string | undefined;
  ico?: string | undefined;
  isActive?: boolean | undefined;
  userCategories?: UserCategory[] | undefined;
  invoices?: Invoice[] | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class CategoryResponse implements ICategoryResponse {
  name?: string | undefined;
  description?: string | undefined;
  ico?: string | undefined;
  isActive?: boolean | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: ICategoryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.ico = _data["ico"];
      this.isActive = _data["isActive"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CategoryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CategoryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["ico"] = this.ico;
    data["isActive"] = this.isActive;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ICategoryResponse {
  name?: string | undefined;
  description?: string | undefined;
  ico?: string | undefined;
  isActive?: boolean | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmationPassword?: string | undefined;

  constructor(data?: IChangePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.oldPassword = _data["oldPassword"];
      this.newPassword = _data["newPassword"];
      this.confirmationPassword = _data["confirmationPassword"];
    }
  }

  static fromJS(data: any): ChangePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["oldPassword"] = this.oldPassword;
    data["newPassword"] = this.newPassword;
    data["confirmationPassword"] = this.confirmationPassword;
    return data;
  }
}

export interface IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmationPassword?: string | undefined;
}

export class CreateInvoiceCommand implements ICreateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  note?: CreateOrUpdateNoteCommand | undefined;

  constructor(data?: ICreateInvoiceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.categoryId = _data["categoryId"];
      this.currencyId = _data["currencyId"];
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.type = _data["type"];
      this.note = _data["note"] ? CreateOrUpdateNoteCommand.fromJS(_data["note"]) : <any>undefined;
    }
  }

  static fromJS(data: any): CreateInvoiceCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateInvoiceCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["categoryId"] = this.categoryId;
    data["currencyId"] = this.currencyId;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["type"] = this.type;
    data["note"] = this.note ? this.note.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  note?: CreateOrUpdateNoteCommand | undefined;
}

export class CreateOrUpdateNoteCommand implements ICreateOrUpdateNoteCommand {
  name?: string | undefined;
  body?: string | undefined;
  id?: string | undefined;

  constructor(data?: ICreateOrUpdateNoteCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.body = _data["body"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CreateOrUpdateNoteCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateOrUpdateNoteCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["body"] = this.body;
    data["id"] = this.id;
    return data;
  }
}

export interface ICreateOrUpdateNoteCommand {
  name?: string | undefined;
  body?: string | undefined;
  id?: string | undefined;
}

export class CreateUserByAdminCommand implements ICreateUserByAdminCommand {
  isTemporaryPassword?: boolean | undefined;
  isBlocked?: boolean | undefined;
  tariffId?: string | undefined;
  currencyId?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;

  constructor(data?: ICreateUserByAdminCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isTemporaryPassword = _data["isTemporaryPassword"];
      this.isBlocked = _data["isBlocked"];
      this.tariffId = _data["tariffId"];
      this.currencyId = _data["currencyId"];
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.confirmEmail = _data["confirmEmail"];
      this.isAgree = _data["isAgree"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isAgreeDigest = _data["isAgreeDigest"];
    }
  }

  static fromJS(data: any): CreateUserByAdminCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserByAdminCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isTemporaryPassword"] = this.isTemporaryPassword;
    data["isBlocked"] = this.isBlocked;
    data["tariffId"] = this.tariffId;
    data["currencyId"] = this.currencyId;
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["confirmEmail"] = this.confirmEmail;
    data["isAgree"] = this.isAgree;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isAgreeDigest"] = this.isAgreeDigest;
    return data;
  }
}

export interface ICreateUserByAdminCommand {
  isTemporaryPassword?: boolean | undefined;
  isBlocked?: boolean | undefined;
  tariffId?: string | undefined;
  currencyId?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;

  constructor(data?: ICreateUserCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.confirmEmail = _data["confirmEmail"];
      this.isAgree = _data["isAgree"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isAgreeDigest = _data["isAgreeDigest"];
    }
  }

  static fromJS(data: any): CreateUserCommand {
    data = typeof data === 'object' ? data : {};
    let result = new CreateUserCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["confirmEmail"] = this.confirmEmail;
    data["isAgree"] = this.isAgree;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isAgreeDigest"] = this.isAgreeDigest;
    return data;
  }
}

export interface ICreateUserCommand {
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;
}

export class Currency implements ICurrency {
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  isActive?: boolean | undefined;
  users?: User[] | undefined;
  invoices?: Invoice[] | undefined;
  userBalances?: UserBalance[] | undefined;
  id?: string | undefined;

  constructor(data?: ICurrency) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isoCode = _data["isoCode"];
      this.symbol = _data["symbol"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["users"])) {
        this.users = [] as any;
        for (let item of _data["users"])
          this.users!.push(User.fromJS(item));
      }
      if (Array.isArray(_data["invoices"])) {
        this.invoices = [] as any;
        for (let item of _data["invoices"])
          this.invoices!.push(Invoice.fromJS(item));
      }
      if (Array.isArray(_data["userBalances"])) {
        this.userBalances = [] as any;
        for (let item of _data["userBalances"])
          this.userBalances!.push(UserBalance.fromJS(item));
      }
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Currency {
    data = typeof data === 'object' ? data : {};
    let result = new Currency();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isoCode"] = this.isoCode;
    data["symbol"] = this.symbol;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    if (Array.isArray(this.users)) {
      data["users"] = [];
      for (let item of this.users)
        data["users"].push(item.toJSON());
    }
    if (Array.isArray(this.invoices)) {
      data["invoices"] = [];
      for (let item of this.invoices)
        data["invoices"].push(item.toJSON());
    }
    if (Array.isArray(this.userBalances)) {
      data["userBalances"] = [];
      for (let item of this.userBalances)
        data["userBalances"].push(item.toJSON());
    }
    data["id"] = this.id;
    return data;
  }
}

export interface ICurrency {
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  isActive?: boolean | undefined;
  users?: User[] | undefined;
  invoices?: Invoice[] | undefined;
  userBalances?: UserBalance[] | undefined;
  id?: string | undefined;
}

export class CurrencyEntity implements ICurrencyEntity {
  entityId?: string | undefined;
  entityType?: EntityTypeEnum | undefined;
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  isDefault?: boolean | undefined;
  tariffId?: string | undefined;
  tariff?: Tariff | undefined;
  id?: string | undefined;

  constructor(data?: ICurrencyEntity) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityId = _data["entityId"];
      this.entityType = _data["entityType"];
      this.amount = _data["amount"];
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
      this.isDefault = _data["isDefault"];
      this.tariffId = _data["tariffId"];
      this.tariff = _data["tariff"] ? Tariff.fromJS(_data["tariff"]) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CurrencyEntity {
    data = typeof data === 'object' ? data : {};
    let result = new CurrencyEntity();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["entityId"] = this.entityId;
    data["entityType"] = this.entityType;
    data["amount"] = this.amount;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["isDefault"] = this.isDefault;
    data["tariffId"] = this.tariffId;
    data["tariff"] = this.tariff ? this.tariff.toJSON() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ICurrencyEntity {
  entityId?: string | undefined;
  entityType?: EntityTypeEnum | undefined;
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  isDefault?: boolean | undefined;
  tariffId?: string | undefined;
  tariff?: Tariff | undefined;
  id?: string | undefined;
}

export class CurrencyEntityResponse implements ICurrencyEntityResponse {
  entityId?: string | undefined;
  entityType?: EntityTypeEnum | undefined;
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  isDefault?: boolean | undefined;
  tariffId?: string | undefined;
  tariff?: TariffResponse | undefined;
  id?: string | undefined;

  constructor(data?: ICurrencyEntityResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityId = _data["entityId"];
      this.entityType = _data["entityType"];
      this.amount = _data["amount"];
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.isDefault = _data["isDefault"];
      this.tariffId = _data["tariffId"];
      this.tariff = _data["tariff"] ? TariffResponse.fromJS(_data["tariff"]) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CurrencyEntityResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CurrencyEntityResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["entityId"] = this.entityId;
    data["entityType"] = this.entityType;
    data["amount"] = this.amount;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["isDefault"] = this.isDefault;
    data["tariffId"] = this.tariffId;
    data["tariff"] = this.tariff ? this.tariff.toJSON() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ICurrencyEntityResponse {
  entityId?: string | undefined;
  entityType?: EntityTypeEnum | undefined;
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  isDefault?: boolean | undefined;
  tariffId?: string | undefined;
  tariff?: TariffResponse | undefined;
  id?: string | undefined;
}

export class CurrencyResponse implements ICurrencyResponse {
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  isActive?: boolean | undefined;
  id?: string | undefined;

  constructor(data?: ICurrencyResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isoCode = _data["isoCode"];
      this.symbol = _data["symbol"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): CurrencyResponse {
    data = typeof data === 'object' ? data : {};
    let result = new CurrencyResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isoCode"] = this.isoCode;
    data["symbol"] = this.symbol;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    data["id"] = this.id;
    return data;
  }
}

export interface ICurrencyResponse {
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  isActive?: boolean | undefined;
  id?: string | undefined;
}

export class CurrencySearchModel implements ICurrencySearchModel {
  id?: string | undefined;
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  isActive?: boolean | undefined;

  constructor(data?: ICurrencySearchModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isoCode = _data["isoCode"];
      this.symbol = _data["symbol"];
      this.name = _data["name"];
      this.isActive = _data["isActive"];
    }
  }

  static fromJS(data: any): CurrencySearchModel {
    data = typeof data === 'object' ? data : {};
    let result = new CurrencySearchModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["isoCode"] = this.isoCode;
    data["symbol"] = this.symbol;
    data["name"] = this.name;
    data["isActive"] = this.isActive;
    return data;
  }
}

export interface ICurrencySearchModel {
  id?: string | undefined;
  isoCode?: string | undefined;
  symbol?: string | undefined;
  name?: string | undefined;
  isActive?: boolean | undefined;
}

export class DictionariesResponse implements IDictionariesResponse {
  currencies?: GuidDictionaryResponse | undefined;
  categories?: GuidDictionaryResponse | undefined;
  roles?: GuidDictionaryResponse | undefined;
  tariffs?: GuidDictionaryResponse | undefined;
  invoiceTypes?: StringDictionaryResponse | undefined;

  constructor(data?: IDictionariesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.currencies = _data["currencies"] ? GuidDictionaryResponse.fromJS(_data["currencies"]) : <any>undefined;
      this.categories = _data["categories"] ? GuidDictionaryResponse.fromJS(_data["categories"]) : <any>undefined;
      this.roles = _data["roles"] ? GuidDictionaryResponse.fromJS(_data["roles"]) : <any>undefined;
      this.tariffs = _data["tariffs"] ? GuidDictionaryResponse.fromJS(_data["tariffs"]) : <any>undefined;
      this.invoiceTypes = _data["invoiceTypes"] ? StringDictionaryResponse.fromJS(_data["invoiceTypes"]) : <any>undefined;
    }
  }

  static fromJS(data: any): DictionariesResponse {
    data = typeof data === 'object' ? data : {};
    let result = new DictionariesResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currencies"] = this.currencies ? this.currencies.toJSON() : <any>undefined;
    data["categories"] = this.categories ? this.categories.toJSON() : <any>undefined;
    data["roles"] = this.roles ? this.roles.toJSON() : <any>undefined;
    data["tariffs"] = this.tariffs ? this.tariffs.toJSON() : <any>undefined;
    data["invoiceTypes"] = this.invoiceTypes ? this.invoiceTypes.toJSON() : <any>undefined;
    return data;
  }
}

export interface IDictionariesResponse {
  currencies?: GuidDictionaryResponse | undefined;
  categories?: GuidDictionaryResponse | undefined;
  roles?: GuidDictionaryResponse | undefined;
  tariffs?: GuidDictionaryResponse | undefined;
  invoiceTypes?: StringDictionaryResponse | undefined;
}

export enum DictionaryTypeEnum {
  TARIFF = "TARIFF",
  CATEGORY = "CATEGORY",
  CURRENCY = "CURRENCY",
  ROLE = "ROLE",
  INVOICE_TYPE = "INVOICE_TYPE",
}

export enum EntityTypeEnum {
  USER = "USER",
}

export class ErrorMessage implements IErrorMessage {
  invalidFields?: InvalidFieldInfo[] | undefined;
  message?: string | undefined;
  statusCode?: number | undefined;

  constructor(data?: IErrorMessage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["invalidFields"])) {
        this.invalidFields = [] as any;
        for (let item of _data["invalidFields"])
          this.invalidFields!.push(InvalidFieldInfo.fromJS(item));
      }
      this.message = _data["message"];
      this.statusCode = _data["statusCode"];
    }
  }

  static fromJS(data: any): ErrorMessage {
    data = typeof data === 'object' ? data : {};
    let result = new ErrorMessage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.invalidFields)) {
      data["invalidFields"] = [];
      for (let item of this.invalidFields)
        data["invalidFields"].push(item.toJSON());
    }
    data["message"] = this.message;
    data["statusCode"] = this.statusCode;
    return data;
  }
}

export interface IErrorMessage {
  invalidFields?: InvalidFieldInfo[] | undefined;
  message?: string | undefined;
  statusCode?: number | undefined;
}

export enum FileTypeEnum {
  USER_IMAGE = "USER_IMAGE",
  CATEGORY_ICO = "CATEGORY_ICO",
}

export class ForgotPasswordQuery implements IForgotPasswordQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;

  constructor(data?: IForgotPasswordQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
    }
  }

  static fromJS(data: any): ForgotPasswordQuery {
    data = typeof data === 'object' ? data : {};
    let result = new ForgotPasswordQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    return data;
  }
}

export interface IForgotPasswordQuery {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
}

export class FormButtonModel implements IFormButtonModel {
  title?: string | undefined;

  constructor(data?: IFormButtonModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data["title"];
    }
  }

  static fromJS(data: any): FormButtonModel {
    data = typeof data === 'object' ? data : {};
    let result = new FormButtonModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["title"] = this.title;
    return data;
  }
}

export interface IFormButtonModel {
  title?: string | undefined;
}

export enum FormItemInputDateTypeEnum {
  String = "String",
  Number = "Number",
  Boolean = "Boolean",
  Guid = "Guid",
}

export enum FormItemInputType {
  Select = "Select",
  Date = "Date",
  Daterange = "Daterange",
  Checkbox = "Checkbox",
  Radio = "Radio",
  Text = "Text",
  Password = "Password",
}

export class FormItemModel implements IFormItemModel {
  name?: string | undefined;
  defaultValue?: any | undefined;
  valueType?: FormItemInputDateTypeEnum | undefined;
  inputType?: FormItemInputType | undefined;
  inputTypeStr?: string | undefined;
  selectDataType?: DictionaryTypeEnum | undefined;
  validators?: FormItemValidatorModel[] | undefined;
  label?: string | undefined;
  placeholder?: string | undefined;
  inline?: boolean | undefined;
  okHint?: FormItemOkHintModel | undefined;
  wrapperType?: FormItemWrapperTypeEnum | undefined;

  constructor(data?: IFormItemModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.defaultValue = _data["defaultValue"];
      this.valueType = _data["valueType"];
      this.inputType = _data["inputType"];
      this.inputTypeStr = _data["inputTypeStr"];
      this.selectDataType = _data["selectDataType"];
      if (Array.isArray(_data["validators"])) {
        this.validators = [] as any;
        for (let item of _data["validators"])
          this.validators!.push(FormItemValidatorModel.fromJS(item));
      }
      this.label = _data["label"];
      this.placeholder = _data["placeholder"];
      this.inline = _data["inline"];
      this.okHint = _data["okHint"] ? FormItemOkHintModel.fromJS(_data["okHint"]) : <any>undefined;
      this.wrapperType = _data["wrapperType"];
    }
  }

  static fromJS(data: any): FormItemModel {
    data = typeof data === 'object' ? data : {};
    let result = new FormItemModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["defaultValue"] = this.defaultValue;
    data["valueType"] = this.valueType;
    data["inputType"] = this.inputType;
    data["inputTypeStr"] = this.inputTypeStr;
    data["selectDataType"] = this.selectDataType;
    if (Array.isArray(this.validators)) {
      data["validators"] = [];
      for (let item of this.validators)
        data["validators"].push(item.toJSON());
    }
    data["label"] = this.label;
    data["placeholder"] = this.placeholder;
    data["inline"] = this.inline;
    data["okHint"] = this.okHint ? this.okHint.toJSON() : <any>undefined;
    data["wrapperType"] = this.wrapperType;
    return data;
  }
}

export interface IFormItemModel {
  name?: string | undefined;
  defaultValue?: any | undefined;
  valueType?: FormItemInputDateTypeEnum | undefined;
  inputType?: FormItemInputType | undefined;
  inputTypeStr?: string | undefined;
  selectDataType?: DictionaryTypeEnum | undefined;
  validators?: FormItemValidatorModel[] | undefined;
  label?: string | undefined;
  placeholder?: string | undefined;
  inline?: boolean | undefined;
  okHint?: FormItemOkHintModel | undefined;
  wrapperType?: FormItemWrapperTypeEnum | undefined;
}

export class FormItemOkHintModel implements IFormItemOkHintModel {
  isOk?: boolean | undefined;
  yes?: string | undefined;
  no?: string | undefined;

  constructor(data?: IFormItemOkHintModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isOk = _data["isOk"];
      this.yes = _data["yes"];
      this.no = _data["no"];
    }
  }

  static fromJS(data: any): FormItemOkHintModel {
    data = typeof data === 'object' ? data : {};
    let result = new FormItemOkHintModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isOk"] = this.isOk;
    data["yes"] = this.yes;
    data["no"] = this.no;
    return data;
  }
}

export interface IFormItemOkHintModel {
  isOk?: boolean | undefined;
  yes?: string | undefined;
  no?: string | undefined;
}

export class FormItemValidatorModel implements IFormItemValidatorModel {
  validatorType?: FormItemValidatorTypeEnum | undefined;
  value?: string | undefined;

  constructor(data?: IFormItemValidatorModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.validatorType = _data["validatorType"];
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): FormItemValidatorModel {
    data = typeof data === 'object' ? data : {};
    let result = new FormItemValidatorModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["validatorType"] = this.validatorType;
    data["value"] = this.value;
    return data;
  }
}

export interface IFormItemValidatorModel {
  validatorType?: FormItemValidatorTypeEnum | undefined;
  value?: string | undefined;
}

export enum FormItemValidatorTypeEnum {
  MinLen = "MinLen",
  MaxLen = "MaxLen",
  Required = "Required",
  Min = "Min",
  Max = "Max",
  Email = "Email",
  AtLeastOne = "AtLeastOne",
  Pattern = "Pattern",
}

export enum FormItemWrapperTypeEnum {
  Full = "Full",
  Half = "Half",
  Third = "Third",
  Quarter = "Quarter",
}

export class FormModel implements IFormModel {
  type?: FormTypeEnum | undefined;
  controls?: FormItemModel[] | undefined;
  title?: string | undefined;
  submitButton?: FormButtonModel | undefined;
  cancelButton?: FormButtonModel | undefined;

  constructor(data?: IFormModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      if (Array.isArray(_data["controls"])) {
        this.controls = [] as any;
        for (let item of _data["controls"])
          this.controls!.push(FormItemModel.fromJS(item));
      }
      this.title = _data["title"];
      this.submitButton = _data["submitButton"] ? FormButtonModel.fromJS(_data["submitButton"]) : <any>undefined;
      this.cancelButton = _data["cancelButton"] ? FormButtonModel.fromJS(_data["cancelButton"]) : <any>undefined;
    }
  }

  static fromJS(data: any): FormModel {
    data = typeof data === 'object' ? data : {};
    let result = new FormModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["type"] = this.type;
    if (Array.isArray(this.controls)) {
      data["controls"] = [];
      for (let item of this.controls)
        data["controls"].push(item.toJSON());
    }
    data["title"] = this.title;
    data["submitButton"] = this.submitButton ? this.submitButton.toJSON() : <any>undefined;
    data["cancelButton"] = this.cancelButton ? this.cancelButton.toJSON() : <any>undefined;
    return data;
  }
}

export interface IFormModel {
  type?: FormTypeEnum | undefined;
  controls?: FormItemModel[] | undefined;
  title?: string | undefined;
  submitButton?: FormButtonModel | undefined;
  cancelButton?: FormButtonModel | undefined;
}

export enum FormTypeEnum {
  AUTH_LOGIN = "AUTH_LOGIN",
}

export class GuidDictionaryItemResponse implements IGuidDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;

  constructor(data?: IGuidDictionaryItemResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.hint = _data["hint"];
    }
  }

  static fromJS(data: any): GuidDictionaryItemResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GuidDictionaryItemResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["hint"] = this.hint;
    return data;
  }
}

export interface IGuidDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;
}

export class GuidDictionaryResponse implements IGuidDictionaryResponse {
  items?: GuidDictionaryItemResponse[] | undefined;

  constructor(data?: IGuidDictionaryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(GuidDictionaryItemResponse.fromJS(item));
      }
    }
  }

  static fromJS(data: any): GuidDictionaryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new GuidDictionaryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IGuidDictionaryResponse {
  items?: GuidDictionaryItemResponse[] | undefined;
}

export class ImageDataResponse implements IImageDataResponse {
  entityId?: string | undefined;
  type?: FileTypeEnum | undefined;
  name?: string | undefined;
  data?: string | undefined;
  id?: string | undefined;

  constructor(data?: IImageDataResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.entityId = _data["entityId"];
      this.type = _data["type"];
      this.name = _data["name"];
      this.data = _data["data"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): ImageDataResponse {
    data = typeof data === 'object' ? data : {};
    let result = new ImageDataResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["entityId"] = this.entityId;
    data["type"] = this.type;
    data["name"] = this.name;
    data["data"] = this.data;
    data["id"] = this.id;
    return data;
  }
}

export interface IImageDataResponse {
  entityId?: string | undefined;
  type?: FileTypeEnum | undefined;
  name?: string | undefined;
  data?: string | undefined;
  id?: string | undefined;
}

export class ImageDataResponseListWithIncludeHelper implements IImageDataResponseListWithIncludeHelper {
  entities?: ImageDataResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;

  constructor(data?: IImageDataResponseListWithIncludeHelper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["entities"])) {
        this.entities = [] as any;
        for (let item of _data["entities"])
          this.entities!.push(ImageDataResponse.fromJS(item));
      }
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): ImageDataResponseListWithIncludeHelper {
    data = typeof data === 'object' ? data : {};
    let result = new ImageDataResponseListWithIncludeHelper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.entities)) {
      data["entities"] = [];
      for (let item of this.entities)
        data["entities"].push(item.toJSON());
    }
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["totalCount"] = this.totalCount;
    return data;
  }
}

export interface IImageDataResponseListWithIncludeHelper {
  entities?: ImageDataResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;
}

export class InvalidFieldInfo implements IInvalidFieldInfo {
  propertyName?: string | undefined;
  code?: string | undefined;
  errorMessage?: string | undefined;

  constructor(data?: IInvalidFieldInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.propertyName = _data["propertyName"];
      this.code = _data["code"];
      this.errorMessage = _data["errorMessage"];
    }
  }

  static fromJS(data: any): InvalidFieldInfo {
    data = typeof data === 'object' ? data : {};
    let result = new InvalidFieldInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["propertyName"] = this.propertyName;
    data["code"] = this.code;
    data["errorMessage"] = this.errorMessage;
    return data;
  }
}

export interface IInvalidFieldInfo {
  propertyName?: string | undefined;
  code?: string | undefined;
  errorMessage?: string | undefined;
}

export class Invoice implements IInvoice {
  name?: string | undefined;
  amount?: number | undefined;
  userId?: string | undefined;
  user?: User | undefined;
  categoryId?: string | undefined;
  category?: Category | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  mapped?: Date | undefined;
  date?: Date | undefined;
  noteId?: string | undefined;
  note?: Note | undefined;
  type?: InvoiceTypeEnum | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IInvoice) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.userId = _data["userId"];
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
      this.mapped = _data["mapped"] ? new Date(_data["mapped"].toString()) : <any>undefined;
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.noteId = _data["noteId"];
      this.note = _data["note"] ? Note.fromJS(_data["note"]) : <any>undefined;
      this.type = _data["type"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Invoice {
    data = typeof data === 'object' ? data : {};
    let result = new Invoice();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["mapped"] = this.mapped ? this.mapped.toISOString() : <any>undefined;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["noteId"] = this.noteId;
    data["note"] = this.note ? this.note.toJSON() : <any>undefined;
    data["type"] = this.type;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IInvoice {
  name?: string | undefined;
  amount?: number | undefined;
  userId?: string | undefined;
  user?: User | undefined;
  categoryId?: string | undefined;
  category?: Category | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  mapped?: Date | undefined;
  date?: Date | undefined;
  noteId?: string | undefined;
  note?: Note | undefined;
  type?: InvoiceTypeEnum | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class InvoiceResponse implements IInvoiceResponse {
  name?: string | undefined;
  amount?: number | undefined;
  userId?: string | undefined;
  categoryId?: string | undefined;
  category?: CategoryResponse | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  date?: Date | undefined;
  noteId?: string | undefined;
  note?: NoteResponse | undefined;
  type?: InvoiceTypeEnum | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IInvoiceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.userId = _data["userId"];
      this.categoryId = _data["categoryId"];
      this.category = _data["category"] ? CategoryResponse.fromJS(_data["category"]) : <any>undefined;
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.noteId = _data["noteId"];
      this.note = _data["note"] ? NoteResponse.fromJS(_data["note"]) : <any>undefined;
      this.type = _data["type"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): InvoiceResponse {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["userId"] = this.userId;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["noteId"] = this.noteId;
    data["note"] = this.note ? this.note.toJSON() : <any>undefined;
    data["type"] = this.type;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IInvoiceResponse {
  name?: string | undefined;
  amount?: number | undefined;
  userId?: string | undefined;
  categoryId?: string | undefined;
  category?: CategoryResponse | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  date?: Date | undefined;
  noteId?: string | undefined;
  note?: NoteResponse | undefined;
  type?: InvoiceTypeEnum | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class InvoiceResponseListWithIncludeHelper implements IInvoiceResponseListWithIncludeHelper {
  entities?: InvoiceResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;

  constructor(data?: IInvoiceResponseListWithIncludeHelper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["entities"])) {
        this.entities = [] as any;
        for (let item of _data["entities"])
          this.entities!.push(InvoiceResponse.fromJS(item));
      }
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): InvoiceResponseListWithIncludeHelper {
    data = typeof data === 'object' ? data : {};
    let result = new InvoiceResponseListWithIncludeHelper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.entities)) {
      data["entities"] = [];
      for (let item of this.entities)
        data["entities"].push(item.toJSON());
    }
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["totalCount"] = this.totalCount;
    return data;
  }
}

export interface IInvoiceResponseListWithIncludeHelper {
  entities?: InvoiceResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;
}

export enum InvoiceTypeEnum {
  INCOME = "INCOME",
  EXPENSE = "EXPENSE",
}

export class Note implements INote {
  name!: string;
  body!: string;
  invoiceId?: string | undefined;
  invoice?: Invoice | undefined;
  userId?: string | undefined;
  user?: User | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: INote) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.body = _data["body"];
      this.invoiceId = _data["invoiceId"];
      this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
      this.userId = _data["userId"];
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Note {
    data = typeof data === 'object' ? data : {};
    let result = new Note();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["body"] = this.body;
    data["invoiceId"] = this.invoiceId;
    data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface INote {
  name: string;
  body: string;
  invoiceId?: string | undefined;
  invoice?: Invoice | undefined;
  userId?: string | undefined;
  user?: User | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class NoteResponse implements INoteResponse {
  name?: string | undefined;
  body?: string | undefined;
  userId?: string | undefined;
  user?: UserResponse | undefined;
  invoiceId?: string | undefined;
  invoice?: InvoiceResponse | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: INoteResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.body = _data["body"];
      this.userId = _data["userId"];
      this.user = _data["user"] ? UserResponse.fromJS(_data["user"]) : <any>undefined;
      this.invoiceId = _data["invoiceId"];
      this.invoice = _data["invoice"] ? InvoiceResponse.fromJS(_data["invoice"]) : <any>undefined;
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): NoteResponse {
    data = typeof data === 'object' ? data : {};
    let result = new NoteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["body"] = this.body;
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["invoiceId"] = this.invoiceId;
    data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface INoteResponse {
  name?: string | undefined;
  body?: string | undefined;
  userId?: string | undefined;
  user?: UserResponse | undefined;
  invoiceId?: string | undefined;
  invoice?: InvoiceResponse | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class Notification implements INotification {
  read?: Date | undefined;
  entityType?: EntityTypeEnum | undefined;
  entityId?: string | undefined;
  type?: number | undefined;
  userId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: INotification) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.read = _data["read"] ? new Date(_data["read"].toString()) : <any>undefined;
      this.entityType = _data["entityType"];
      this.entityId = _data["entityId"];
      this.type = _data["type"];
      this.userId = _data["userId"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Notification {
    data = typeof data === 'object' ? data : {};
    let result = new Notification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["read"] = this.read ? this.read.toISOString() : <any>undefined;
    data["entityType"] = this.entityType;
    data["entityId"] = this.entityId;
    data["type"] = this.type;
    data["userId"] = this.userId;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface INotification {
  read?: Date | undefined;
  entityType?: EntityTypeEnum | undefined;
  entityId?: string | undefined;
  type?: number | undefined;
  userId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class Paginator implements IPaginator {
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  isFull?: boolean | undefined;

  constructor(data?: IPaginator) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageNumber = _data["pageNumber"];
      this.pageSize = _data["pageSize"];
      this.isFull = _data["isFull"];
    }
  }

  static fromJS(data: any): Paginator {
    data = typeof data === 'object' ? data : {};
    let result = new Paginator();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["pageNumber"] = this.pageNumber;
    data["pageSize"] = this.pageSize;
    data["isFull"] = this.isFull;
    return data;
  }
}

export interface IPaginator {
  pageNumber?: number | undefined;
  pageSize?: number | undefined;
  isFull?: boolean | undefined;
}

export class RestorePasswordCommand implements IRestorePasswordCommand {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  url?: string | undefined;

  constructor(data?: IRestorePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.url = _data["url"];
    }
  }

  static fromJS(data: any): RestorePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RestorePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["url"] = this.url;
    return data;
  }
}

export interface IRestorePasswordCommand {
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  url?: string | undefined;
}

export class StringDictionaryItemResponse implements IStringDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;

  constructor(data?: IStringDictionaryItemResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.hint = _data["hint"];
    }
  }

  static fromJS(data: any): StringDictionaryItemResponse {
    data = typeof data === 'object' ? data : {};
    let result = new StringDictionaryItemResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["hint"] = this.hint;
    return data;
  }
}

export interface IStringDictionaryItemResponse {
  id?: string | undefined;
  name?: string | undefined;
  hint?: string | undefined;
}

export class StringDictionaryResponse implements IStringDictionaryResponse {
  items?: StringDictionaryItemResponse[] | undefined;

  constructor(data?: IStringDictionaryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["items"])) {
        this.items = [] as any;
        for (let item of _data["items"])
          this.items!.push(StringDictionaryItemResponse.fromJS(item));
      }
    }
  }

  static fromJS(data: any): StringDictionaryResponse {
    data = typeof data === 'object' ? data : {};
    let result = new StringDictionaryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.items)) {
      data["items"] = [];
      for (let item of this.items)
        data["items"].push(item.toJSON());
    }
    return data;
  }
}

export interface IStringDictionaryResponse {
  items?: StringDictionaryItemResponse[] | undefined;
}

export class Tariff implements ITariff {
  name?: string | undefined;
  description?: string | undefined;
  currencyEntities?: CurrencyEntity[] | undefined;
  isActive?: boolean | undefined;
  users?: User[] | undefined;
  order?: number | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: ITariff) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      if (Array.isArray(_data["currencyEntities"])) {
        this.currencyEntities = [] as any;
        for (let item of _data["currencyEntities"])
          this.currencyEntities!.push(CurrencyEntity.fromJS(item));
      }
      this.isActive = _data["isActive"];
      if (Array.isArray(_data["users"])) {
        this.users = [] as any;
        for (let item of _data["users"])
          this.users!.push(User.fromJS(item));
      }
      this.order = _data["order"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): Tariff {
    data = typeof data === 'object' ? data : {};
    let result = new Tariff();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    if (Array.isArray(this.currencyEntities)) {
      data["currencyEntities"] = [];
      for (let item of this.currencyEntities)
        data["currencyEntities"].push(item.toJSON());
    }
    data["isActive"] = this.isActive;
    if (Array.isArray(this.users)) {
      data["users"] = [];
      for (let item of this.users)
        data["users"].push(item.toJSON());
    }
    data["order"] = this.order;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ITariff {
  name?: string | undefined;
  description?: string | undefined;
  currencyEntities?: CurrencyEntity[] | undefined;
  isActive?: boolean | undefined;
  users?: User[] | undefined;
  order?: number | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class TariffResponse implements ITariffResponse {
  name?: string | undefined;
  description?: string | undefined;
  currencyEntities?: CurrencyEntityResponse[] | undefined;
  isActive?: boolean | undefined;
  order?: number | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: ITariffResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      if (Array.isArray(_data["currencyEntities"])) {
        this.currencyEntities = [] as any;
        for (let item of _data["currencyEntities"])
          this.currencyEntities!.push(CurrencyEntityResponse.fromJS(item));
      }
      this.isActive = _data["isActive"];
      this.order = _data["order"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): TariffResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TariffResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    if (Array.isArray(this.currencyEntities)) {
      data["currencyEntities"] = [];
      for (let item of this.currencyEntities)
        data["currencyEntities"].push(item.toJSON());
    }
    data["isActive"] = this.isActive;
    data["order"] = this.order;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface ITariffResponse {
  name?: string | undefined;
  description?: string | undefined;
  currencyEntities?: CurrencyEntityResponse[] | undefined;
  isActive?: boolean | undefined;
  order?: number | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class TariffResponseListWithIncludeHelper implements ITariffResponseListWithIncludeHelper {
  entities?: TariffResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;

  constructor(data?: ITariffResponseListWithIncludeHelper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["entities"])) {
        this.entities = [] as any;
        for (let item of _data["entities"])
          this.entities!.push(TariffResponse.fromJS(item));
      }
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): TariffResponseListWithIncludeHelper {
    data = typeof data === 'object' ? data : {};
    let result = new TariffResponseListWithIncludeHelper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.entities)) {
      data["entities"] = [];
      for (let item of this.entities)
        data["entities"].push(item.toJSON());
    }
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["totalCount"] = this.totalCount;
    return data;
  }
}

export interface ITariffResponseListWithIncludeHelper {
  entities?: TariffResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;
}

export class TariffsQuery implements ITariffsQuery {
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;

  constructor(data?: ITariffsQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ids = _data["ids"] ? BaseIdsListQuery.fromJS(_data["ids"]) : <any>undefined;
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.dateRange = _data["dateRange"] ? BaseDateRangeQuery.fromJS(_data["dateRange"]) : <any>undefined;
      this.sort = _data["sort"] ? BaseSortableQuery.fromJS(_data["sort"]) : <any>undefined;
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): TariffsQuery {
    data = typeof data === 'object' ? data : {};
    let result = new TariffsQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ids"] = this.ids ? this.ids.toJSON() : <any>undefined;
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["dateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
    data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    return data;
  }
}

export interface ITariffsQuery {
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;
}

export class TokenResponse implements ITokenResponse {
  scheme?: string | undefined;
  provider?: string | undefined;
  value?: any | undefined;
  expired?: number | undefined;

  constructor(data?: ITokenResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.scheme = _data["scheme"];
      this.provider = _data["provider"];
      this.value = _data["value"];
      this.expired = _data["expired"];
    }
  }

  static fromJS(data: any): TokenResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TokenResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["scheme"] = this.scheme;
    data["provider"] = this.provider;
    data["value"] = this.value;
    data["expired"] = this.expired;
    return data;
  }
}

export interface ITokenResponse {
  scheme?: string | undefined;
  provider?: string | undefined;
  value?: any | undefined;
  expired?: number | undefined;
}

export class UpdateInvoiceCommand implements IUpdateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  note?: CreateOrUpdateNoteCommand | undefined;
  id?: string | undefined;

  constructor(data?: IUpdateInvoiceCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data["name"];
      this.amount = _data["amount"];
      this.categoryId = _data["categoryId"];
      this.currencyId = _data["currencyId"];
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.type = _data["type"];
      this.note = _data["note"] ? CreateOrUpdateNoteCommand.fromJS(_data["note"]) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UpdateInvoiceCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateInvoiceCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["amount"] = this.amount;
    data["categoryId"] = this.categoryId;
    data["currencyId"] = this.currencyId;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["type"] = this.type;
    data["note"] = this.note ? this.note.toJSON() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IUpdateInvoiceCommand {
  name?: string | undefined;
  amount?: number | undefined;
  categoryId?: string | undefined;
  currencyId?: string | undefined;
  date?: Date | undefined;
  type?: InvoiceTypeEnum | undefined;
  note?: CreateOrUpdateNoteCommand | undefined;
  id?: string | undefined;
}

export class UpdateUserByAdminCommand implements IUpdateUserByAdminCommand {
  id?: string | undefined;
  isTemporaryPassword?: boolean | undefined;
  isBlocked?: boolean | undefined;
  tariffId?: string | undefined;
  currencyId?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;

  constructor(data?: IUpdateUserByAdminCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.isTemporaryPassword = _data["isTemporaryPassword"];
      this.isBlocked = _data["isBlocked"];
      this.tariffId = _data["tariffId"];
      this.currencyId = _data["currencyId"];
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.login = _data["login"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.confirmEmail = _data["confirmEmail"];
      this.isAgree = _data["isAgree"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isAgreeDigest = _data["isAgreeDigest"];
    }
  }

  static fromJS(data: any): UpdateUserByAdminCommand {
    data = typeof data === 'object' ? data : {};
    let result = new UpdateUserByAdminCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["isTemporaryPassword"] = this.isTemporaryPassword;
    data["isBlocked"] = this.isBlocked;
    data["tariffId"] = this.tariffId;
    data["currencyId"] = this.currencyId;
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["login"] = this.login;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["confirmEmail"] = this.confirmEmail;
    data["isAgree"] = this.isAgree;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isAgreeDigest"] = this.isAgreeDigest;
    return data;
  }
}

export interface IUpdateUserByAdminCommand {
  id?: string | undefined;
  isTemporaryPassword?: boolean | undefined;
  isBlocked?: boolean | undefined;
  tariffId?: string | undefined;
  currencyId?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phone?: string | undefined;
  confirmEmail?: string | undefined;
  isAgree?: boolean | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAgreeDigest?: boolean | undefined;
}

export class User implements IUser {
  login!: string;
  lastName!: string;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  salt?: string | undefined;
  isTemporaryPassword?: boolean | undefined;
  isBlocked?: boolean | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  lastForgot?: Date | undefined;
  mapped?: Date | undefined;
  restored?: Date | undefined;
  tariffId?: string | undefined;
  tariff?: Tariff | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  notifications?: Notification[] | undefined;
  userCategories?: UserCategory[] | undefined;
  invoices?: Invoice[] | undefined;
  notes?: Note[] | undefined;
  userBalanceId?: string | undefined;
  userBalance?: UserBalance | undefined;
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean | undefined;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean | undefined;
  twoFactorEnabled?: boolean | undefined;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean | undefined;
  accessFailedCount?: number | undefined;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.salt = _data["salt"];
      this.isTemporaryPassword = _data["isTemporaryPassword"];
      this.isBlocked = _data["isBlocked"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.lastForgot = _data["lastForgot"] ? new Date(_data["lastForgot"].toString()) : <any>undefined;
      this.mapped = _data["mapped"] ? new Date(_data["mapped"].toString()) : <any>undefined;
      this.restored = _data["restored"] ? new Date(_data["restored"].toString()) : <any>undefined;
      this.tariffId = _data["tariffId"];
      this.tariff = _data["tariff"] ? Tariff.fromJS(_data["tariff"]) : <any>undefined;
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
      if (Array.isArray(_data["notifications"])) {
        this.notifications = [] as any;
        for (let item of _data["notifications"])
          this.notifications!.push(Notification.fromJS(item));
      }
      if (Array.isArray(_data["userCategories"])) {
        this.userCategories = [] as any;
        for (let item of _data["userCategories"])
          this.userCategories!.push(UserCategory.fromJS(item));
      }
      if (Array.isArray(_data["invoices"])) {
        this.invoices = [] as any;
        for (let item of _data["invoices"])
          this.invoices!.push(Invoice.fromJS(item));
      }
      if (Array.isArray(_data["notes"])) {
        this.notes = [] as any;
        for (let item of _data["notes"])
          this.notes!.push(Note.fromJS(item));
      }
      this.userBalanceId = _data["userBalanceId"];
      this.userBalance = _data["userBalance"] ? UserBalance.fromJS(_data["userBalance"]) : <any>undefined;
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.normalizedUserName = _data["normalizedUserName"];
      this.email = _data["email"];
      this.normalizedEmail = _data["normalizedEmail"];
      this.emailConfirmed = _data["emailConfirmed"];
      this.passwordHash = _data["passwordHash"];
      this.securityStamp = _data["securityStamp"];
      this.concurrencyStamp = _data["concurrencyStamp"];
      this.phoneNumber = _data["phoneNumber"];
      this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
      this.twoFactorEnabled = _data["twoFactorEnabled"];
      this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
      this.lockoutEnabled = _data["lockoutEnabled"];
      this.accessFailedCount = _data["accessFailedCount"];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["salt"] = this.salt;
    data["isTemporaryPassword"] = this.isTemporaryPassword;
    data["isBlocked"] = this.isBlocked;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["lastForgot"] = this.lastForgot ? this.lastForgot.toISOString() : <any>undefined;
    data["mapped"] = this.mapped ? this.mapped.toISOString() : <any>undefined;
    data["restored"] = this.restored ? this.restored.toISOString() : <any>undefined;
    data["tariffId"] = this.tariffId;
    data["tariff"] = this.tariff ? this.tariff.toJSON() : <any>undefined;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    if (Array.isArray(this.notifications)) {
      data["notifications"] = [];
      for (let item of this.notifications)
        data["notifications"].push(item.toJSON());
    }
    if (Array.isArray(this.userCategories)) {
      data["userCategories"] = [];
      for (let item of this.userCategories)
        data["userCategories"].push(item.toJSON());
    }
    if (Array.isArray(this.invoices)) {
      data["invoices"] = [];
      for (let item of this.invoices)
        data["invoices"].push(item.toJSON());
    }
    if (Array.isArray(this.notes)) {
      data["notes"] = [];
      for (let item of this.notes)
        data["notes"].push(item.toJSON());
    }
    data["userBalanceId"] = this.userBalanceId;
    data["userBalance"] = this.userBalance ? this.userBalance.toJSON() : <any>undefined;
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["normalizedUserName"] = this.normalizedUserName;
    data["email"] = this.email;
    data["normalizedEmail"] = this.normalizedEmail;
    data["emailConfirmed"] = this.emailConfirmed;
    data["passwordHash"] = this.passwordHash;
    data["securityStamp"] = this.securityStamp;
    data["concurrencyStamp"] = this.concurrencyStamp;
    data["phoneNumber"] = this.phoneNumber;
    data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
    data["twoFactorEnabled"] = this.twoFactorEnabled;
    data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
    data["lockoutEnabled"] = this.lockoutEnabled;
    data["accessFailedCount"] = this.accessFailedCount;
    return data;
  }
}

export interface IUser {
  login: string;
  lastName: string;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  salt?: string | undefined;
  isTemporaryPassword?: boolean | undefined;
  isBlocked?: boolean | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  lastForgot?: Date | undefined;
  mapped?: Date | undefined;
  restored?: Date | undefined;
  tariffId?: string | undefined;
  tariff?: Tariff | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  notifications?: Notification[] | undefined;
  userCategories?: UserCategory[] | undefined;
  invoices?: Invoice[] | undefined;
  notes?: Note[] | undefined;
  userBalanceId?: string | undefined;
  userBalance?: UserBalance | undefined;
  id?: string | undefined;
  userName?: string | undefined;
  normalizedUserName?: string | undefined;
  email?: string | undefined;
  normalizedEmail?: string | undefined;
  emailConfirmed?: boolean | undefined;
  passwordHash?: string | undefined;
  securityStamp?: string | undefined;
  concurrencyStamp?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumberConfirmed?: boolean | undefined;
  twoFactorEnabled?: boolean | undefined;
  lockoutEnd?: Date | undefined;
  lockoutEnabled?: boolean | undefined;
  accessFailedCount?: number | undefined;
}

export class UserBalance implements IUserBalance {
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  userId?: string | undefined;
  user?: User | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IUserBalance) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"];
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
      this.userId = _data["userId"];
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UserBalance {
    data = typeof data === 'object' ? data : {};
    let result = new UserBalance();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["amount"] = this.amount;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IUserBalance {
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: Currency | undefined;
  userId?: string | undefined;
  user?: User | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class UserBalanceResponse implements IUserBalanceResponse {
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  userId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IUserBalanceResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.amount = _data["amount"];
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.userId = _data["userId"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UserBalanceResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserBalanceResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["amount"] = this.amount;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IUserBalanceResponse {
  amount?: number | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  userId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class UserBalanceSearchModel implements IUserBalanceSearchModel {
  id?: string | undefined;
  userId?: string | undefined;
  currencyId?: string | undefined;
  amount?: number | undefined;
  currency?: CurrencySearchModel | undefined;

  constructor(data?: IUserBalanceSearchModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.userId = _data["userId"];
      this.currencyId = _data["currencyId"];
      this.amount = _data["amount"];
      this.currency = _data["currency"] ? CurrencySearchModel.fromJS(_data["currency"]) : <any>undefined;
    }
  }

  static fromJS(data: any): UserBalanceSearchModel {
    data = typeof data === 'object' ? data : {};
    let result = new UserBalanceSearchModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["userId"] = this.userId;
    data["currencyId"] = this.currencyId;
    data["amount"] = this.amount;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserBalanceSearchModel {
  id?: string | undefined;
  userId?: string | undefined;
  currencyId?: string | undefined;
  amount?: number | undefined;
  currency?: CurrencySearchModel | undefined;
}

export class UserCategory implements IUserCategory {
  userId?: string | undefined;
  user?: User | undefined;
  categoryId?: string | undefined;
  category?: Category | undefined;

  constructor(data?: IUserCategory) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data["userId"];
      this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
      this.categoryId = _data["categoryId"];
      this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
    }
  }

  static fromJS(data: any): UserCategory {
    data = typeof data === 'object' ? data : {};
    let result = new UserCategory();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["userId"] = this.userId;
    data["user"] = this.user ? this.user.toJSON() : <any>undefined;
    data["categoryId"] = this.categoryId;
    data["category"] = this.category ? this.category.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserCategory {
  userId?: string | undefined;
  user?: User | undefined;
  categoryId?: string | undefined;
  category?: Category | undefined;
}

export class UserImageQuery implements IUserImageQuery {
  type?: FileTypeEnum | undefined;
  userId?: string | undefined;
  id?: string | undefined;

  constructor(data?: IUserImageQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.userId = _data["userId"];
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UserImageQuery {
    data = typeof data === 'object' ? data : {};
    let result = new UserImageQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["type"] = this.type;
    data["userId"] = this.userId;
    data["id"] = this.id;
    return data;
  }
}

export interface IUserImageQuery {
  type?: FileTypeEnum | undefined;
  userId?: string | undefined;
  id?: string | undefined;
}

export class UserInvoicesQuery implements IUserInvoicesQuery {
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;

  constructor(data?: IUserInvoicesQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ids = _data["ids"] ? BaseIdsListQuery.fromJS(_data["ids"]) : <any>undefined;
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.dateRange = _data["dateRange"] ? BaseDateRangeQuery.fromJS(_data["dateRange"]) : <any>undefined;
      this.sort = _data["sort"] ? BaseSortableQuery.fromJS(_data["sort"]) : <any>undefined;
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): UserInvoicesQuery {
    data = typeof data === 'object' ? data : {};
    let result = new UserInvoicesQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ids"] = this.ids ? this.ids.toJSON() : <any>undefined;
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["dateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
    data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    return data;
  }
}

export interface IUserInvoicesQuery {
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;
}

export class UserResponse implements IUserResponse {
  login?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  email?: string | undefined;
  lastForgot?: Date | undefined;
  isTemporaryPassword?: boolean | undefined;
  need2FAuthentication?: boolean | undefined;
  isBlocked?: boolean | undefined;
  roleId?: string | undefined;
  phoneNumber?: string | undefined;
  role?: string | undefined;
  userBalanceId?: string | undefined;
  userBalance?: UserBalanceResponse | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  tariffId?: string | undefined;
  tariff?: TariffResponse | undefined;
  emailConfirmed?: boolean | undefined;
  phoneNumberConfirmed?: boolean | undefined;
  balanceAmount?: number | undefined;
  avatar?: ImageDataResponse | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;

  constructor(data?: IUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.login = _data["login"];
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.patronymic = _data["patronymic"];
      this.email = _data["email"];
      this.lastForgot = _data["lastForgot"] ? new Date(_data["lastForgot"].toString()) : <any>undefined;
      this.isTemporaryPassword = _data["isTemporaryPassword"];
      this.need2FAuthentication = _data["need2FAuthentication"];
      this.isBlocked = _data["isBlocked"];
      this.roleId = _data["roleId"];
      this.phoneNumber = _data["phoneNumber"];
      this.role = _data["role"];
      this.userBalanceId = _data["userBalanceId"];
      this.userBalance = _data["userBalance"] ? UserBalanceResponse.fromJS(_data["userBalance"]) : <any>undefined;
      this.currencyId = _data["currencyId"];
      this.currency = _data["currency"] ? CurrencyResponse.fromJS(_data["currency"]) : <any>undefined;
      this.tariffId = _data["tariffId"];
      this.tariff = _data["tariff"] ? TariffResponse.fromJS(_data["tariff"]) : <any>undefined;
      this.emailConfirmed = _data["emailConfirmed"];
      this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
      this.balanceAmount = _data["balanceAmount"];
      this.avatar = _data["avatar"] ? ImageDataResponse.fromJS(_data["avatar"]) : <any>undefined;
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.id = _data["id"];
    }
  }

  static fromJS(data: any): UserResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["login"] = this.login;
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["patronymic"] = this.patronymic;
    data["email"] = this.email;
    data["lastForgot"] = this.lastForgot ? this.lastForgot.toISOString() : <any>undefined;
    data["isTemporaryPassword"] = this.isTemporaryPassword;
    data["need2FAuthentication"] = this.need2FAuthentication;
    data["isBlocked"] = this.isBlocked;
    data["roleId"] = this.roleId;
    data["phoneNumber"] = this.phoneNumber;
    data["role"] = this.role;
    data["userBalanceId"] = this.userBalanceId;
    data["userBalance"] = this.userBalance ? this.userBalance.toJSON() : <any>undefined;
    data["currencyId"] = this.currencyId;
    data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
    data["tariffId"] = this.tariffId;
    data["tariff"] = this.tariff ? this.tariff.toJSON() : <any>undefined;
    data["emailConfirmed"] = this.emailConfirmed;
    data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
    data["balanceAmount"] = this.balanceAmount;
    data["avatar"] = this.avatar ? this.avatar.toJSON() : <any>undefined;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["id"] = this.id;
    return data;
  }
}

export interface IUserResponse {
  login?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  patronymic?: string | undefined;
  email?: string | undefined;
  lastForgot?: Date | undefined;
  isTemporaryPassword?: boolean | undefined;
  need2FAuthentication?: boolean | undefined;
  isBlocked?: boolean | undefined;
  roleId?: string | undefined;
  phoneNumber?: string | undefined;
  role?: string | undefined;
  userBalanceId?: string | undefined;
  userBalance?: UserBalanceResponse | undefined;
  currencyId?: string | undefined;
  currency?: CurrencyResponse | undefined;
  tariffId?: string | undefined;
  tariff?: TariffResponse | undefined;
  emailConfirmed?: boolean | undefined;
  phoneNumberConfirmed?: boolean | undefined;
  balanceAmount?: number | undefined;
  avatar?: ImageDataResponse | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  id?: string | undefined;
}

export class UserResponseListWithIncludeHelper implements IUserResponseListWithIncludeHelper {
  entities?: UserResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;

  constructor(data?: IUserResponseListWithIncludeHelper) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["entities"])) {
        this.entities = [] as any;
        for (let item of _data["entities"])
          this.entities!.push(UserResponse.fromJS(item));
      }
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.totalCount = _data["totalCount"];
    }
  }

  static fromJS(data: any): UserResponseListWithIncludeHelper {
    data = typeof data === 'object' ? data : {};
    let result = new UserResponseListWithIncludeHelper();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.entities)) {
      data["entities"] = [];
      for (let item of this.entities)
        data["entities"].push(item.toJSON());
    }
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["totalCount"] = this.totalCount;
    return data;
  }
}

export interface IUserResponseListWithIncludeHelper {
  entities?: UserResponse[] | undefined;
  paginator?: Paginator | undefined;
  totalCount?: number | undefined;
}

export class UserResponseUserMappedHelperResponse implements IUserResponseUserMappedHelperResponse {
  mappedEntity?: UserResponse | undefined;
  entity?: User | undefined;

  constructor(data?: IUserResponseUserMappedHelperResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.mappedEntity = _data["mappedEntity"] ? UserResponse.fromJS(_data["mappedEntity"]) : <any>undefined;
      this.entity = _data["entity"] ? User.fromJS(_data["entity"]) : <any>undefined;
    }
  }

  static fromJS(data: any): UserResponseUserMappedHelperResponse {
    data = typeof data === 'object' ? data : {};
    let result = new UserResponseUserMappedHelperResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["mappedEntity"] = this.mappedEntity ? this.mappedEntity.toJSON() : <any>undefined;
    data["entity"] = this.entity ? this.entity.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserResponseUserMappedHelperResponse {
  mappedEntity?: UserResponse | undefined;
  entity?: User | undefined;
}

export class UserSearchModel implements IUserSearchModel {
  id?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  isBlocked?: boolean | undefined;
  roleId?: string | undefined;
  tariffId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  userBalance?: UserBalanceSearchModel | undefined;

  constructor(data?: IUserSearchModel) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.lastName = _data["lastName"];
      this.firstName = _data["firstName"];
      this.login = _data["login"];
      this.email = _data["email"];
      this.phoneNumber = _data["phoneNumber"];
      this.isBlocked = _data["isBlocked"];
      this.roleId = _data["roleId"];
      this.tariffId = _data["tariffId"];
      this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
      this.updated = _data["updated"] ? new Date(_data["updated"].toString()) : <any>undefined;
      this.userBalance = _data["userBalance"] ? UserBalanceSearchModel.fromJS(_data["userBalance"]) : <any>undefined;
    }
  }

  static fromJS(data: any): UserSearchModel {
    data = typeof data === 'object' ? data : {};
    let result = new UserSearchModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["lastName"] = this.lastName;
    data["firstName"] = this.firstName;
    data["login"] = this.login;
    data["email"] = this.email;
    data["phoneNumber"] = this.phoneNumber;
    data["isBlocked"] = this.isBlocked;
    data["roleId"] = this.roleId;
    data["tariffId"] = this.tariffId;
    data["created"] = this.created ? this.created.toISOString() : <any>undefined;
    data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
    data["userBalance"] = this.userBalance ? this.userBalance.toJSON() : <any>undefined;
    return data;
  }
}

export interface IUserSearchModel {
  id?: string | undefined;
  lastName?: string | undefined;
  firstName?: string | undefined;
  login?: string | undefined;
  email?: string | undefined;
  phoneNumber?: string | undefined;
  isBlocked?: boolean | undefined;
  roleId?: string | undefined;
  tariffId?: string | undefined;
  created?: Date | undefined;
  updated?: Date | undefined;
  userBalance?: UserBalanceSearchModel | undefined;
}

export class UsersImagesQuery implements IUsersImagesQuery {
  type?: FileTypeEnum | undefined;
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;

  constructor(data?: IUsersImagesQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.ids = _data["ids"] ? BaseIdsListQuery.fromJS(_data["ids"]) : <any>undefined;
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.dateRange = _data["dateRange"] ? BaseDateRangeQuery.fromJS(_data["dateRange"]) : <any>undefined;
      this.sort = _data["sort"] ? BaseSortableQuery.fromJS(_data["sort"]) : <any>undefined;
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): UsersImagesQuery {
    data = typeof data === 'object' ? data : {};
    let result = new UsersImagesQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["type"] = this.type;
    data["ids"] = this.ids ? this.ids.toJSON() : <any>undefined;
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["dateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
    data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    return data;
  }
}

export interface IUsersImagesQuery {
  type?: FileTypeEnum | undefined;
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;
}

export class UsersQuery implements IUsersQuery {
  isBlocked?: boolean | undefined;
  phone?: string | undefined;
  email?: string | undefined;
  login?: string | undefined;
  name?: string | undefined;
  createdRange?: BaseDateRangeQuery | undefined;
  updatedRange?: BaseDateRangeQuery | undefined;
  currencyIds?: BaseIdsListQuery | undefined;
  roleIds?: BaseIdsListQuery | undefined;
  tariffIds?: BaseIdsListQuery | undefined;
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;

  constructor(data?: IUsersQuery) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isBlocked = _data["isBlocked"];
      this.phone = _data["phone"];
      this.email = _data["email"];
      this.login = _data["login"];
      this.name = _data["name"];
      this.createdRange = _data["createdRange"] ? BaseDateRangeQuery.fromJS(_data["createdRange"]) : <any>undefined;
      this.updatedRange = _data["updatedRange"] ? BaseDateRangeQuery.fromJS(_data["updatedRange"]) : <any>undefined;
      this.currencyIds = _data["currencyIds"] ? BaseIdsListQuery.fromJS(_data["currencyIds"]) : <any>undefined;
      this.roleIds = _data["roleIds"] ? BaseIdsListQuery.fromJS(_data["roleIds"]) : <any>undefined;
      this.tariffIds = _data["tariffIds"] ? BaseIdsListQuery.fromJS(_data["tariffIds"]) : <any>undefined;
      this.ids = _data["ids"] ? BaseIdsListQuery.fromJS(_data["ids"]) : <any>undefined;
      this.paginator = _data["paginator"] ? Paginator.fromJS(_data["paginator"]) : <any>undefined;
      this.dateRange = _data["dateRange"] ? BaseDateRangeQuery.fromJS(_data["dateRange"]) : <any>undefined;
      this.sort = _data["sort"] ? BaseSortableQuery.fromJS(_data["sort"]) : <any>undefined;
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): UsersQuery {
    data = typeof data === 'object' ? data : {};
    let result = new UsersQuery();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isBlocked"] = this.isBlocked;
    data["phone"] = this.phone;
    data["email"] = this.email;
    data["login"] = this.login;
    data["name"] = this.name;
    data["createdRange"] = this.createdRange ? this.createdRange.toJSON() : <any>undefined;
    data["updatedRange"] = this.updatedRange ? this.updatedRange.toJSON() : <any>undefined;
    data["currencyIds"] = this.currencyIds ? this.currencyIds.toJSON() : <any>undefined;
    data["roleIds"] = this.roleIds ? this.roleIds.toJSON() : <any>undefined;
    data["tariffIds"] = this.tariffIds ? this.tariffIds.toJSON() : <any>undefined;
    data["ids"] = this.ids ? this.ids.toJSON() : <any>undefined;
    data["paginator"] = this.paginator ? this.paginator.toJSON() : <any>undefined;
    data["dateRange"] = this.dateRange ? this.dateRange.toJSON() : <any>undefined;
    data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
    data["userId"] = this.userId;
    return data;
  }
}

export interface IUsersQuery {
  isBlocked?: boolean | undefined;
  phone?: string | undefined;
  email?: string | undefined;
  login?: string | undefined;
  name?: string | undefined;
  createdRange?: BaseDateRangeQuery | undefined;
  updatedRange?: BaseDateRangeQuery | undefined;
  currencyIds?: BaseIdsListQuery | undefined;
  roleIds?: BaseIdsListQuery | undefined;
  tariffIds?: BaseIdsListQuery | undefined;
  ids?: BaseIdsListQuery | undefined;
  paginator?: Paginator | undefined;
  dateRange?: BaseDateRangeQuery | undefined;
  sort?: BaseSortableQuery | undefined;
  userId?: string | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export class ApiException extends Error {
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
